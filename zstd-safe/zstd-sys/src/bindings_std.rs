/* automatically generated by rust-bindgen */

pub const ZSTD_VERSION_MAJOR: u32 = 1;
pub const ZSTD_VERSION_MINOR: u32 = 3;
pub const ZSTD_VERSION_RELEASE: u32 = 8;
pub const ZSTD_VERSION_NUMBER: u32 = 10308;
pub const ZSTD_CLEVEL_DEFAULT: u32 = 3;
pub const ZSTD_CONTENTSIZE_UNKNOWN: i32 = -1;
pub const ZSTD_CONTENTSIZE_ERROR: i32 = -2;
pub type wchar_t = ::std::os::raw::c_int;
extern "C" {
    pub fn ZSTD_versionNumber() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ZSTD_versionString() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  Simple API"]
    #[doc = "  Compresses `src` content as a single zstd compressed frame into already allocated `dst`."]
    #[doc = "  Hint : compression runs faster if `dstCapacity` >=  `ZSTD_compressBound(srcSize)`."]
    #[doc = "  @return : compressed size written into `dst` (<= `dstCapacity),"]
    #[doc = "            or an error code if it fails (which can be tested using ZSTD_isError())."]
    pub fn ZSTD_compress(
        dst: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        src: *const ::std::os::raw::c_void,
        srcSize: usize,
        compressionLevel: ::std::os::raw::c_int,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_decompress() :"]
    #[doc = "  `compressedSize` : must be the _exact_ size of some number of compressed and/or skippable frames."]
    #[doc = "  `dstCapacity` is an upper bound of originalSize to regenerate."]
    #[doc = "  If user cannot imply a maximum upper bound, it\'s better to use streaming mode to decompress data."]
    #[doc = "  @return : the number of bytes decompressed into `dst` (<= `dstCapacity`),"]
    #[doc = "            or an errorCode if it fails (which can be tested using ZSTD_isError())."]
    pub fn ZSTD_decompress(
        dst: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        src: *const ::std::os::raw::c_void,
        compressedSize: usize,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_getFrameContentSize(
        src: *const ::std::os::raw::c_void,
        srcSize: usize,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[doc = " ZSTD_getDecompressedSize() :"]
    #[doc = "  NOTE: This function is now obsolete, in favor of ZSTD_getFrameContentSize()."]
    #[doc = "  Both functions work the same way, but ZSTD_getDecompressedSize() blends"]
    #[doc = "  \"empty\", \"unknown\" and \"error\" results to the same return value (0),"]
    #[doc = "  while ZSTD_getFrameContentSize() gives them separate return values."]
    #[doc = " @return : decompressed size of `src` frame content _if known and not empty_, 0 otherwise."]
    pub fn ZSTD_getDecompressedSize(
        src: *const ::std::os::raw::c_void,
        srcSize: usize,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn ZSTD_compressBound(srcSize: usize) -> usize;
}
extern "C" {
    pub fn ZSTD_isError(code: usize) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ZSTD_getErrorName(code: usize) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ZSTD_maxCLevel() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_CCtx_s {
    _unused: [u8; 0],
}
#[doc = "  Explicit context"]
pub type ZSTD_CCtx = ZSTD_CCtx_s;
extern "C" {
    pub fn ZSTD_createCCtx() -> *mut ZSTD_CCtx;
}
extern "C" {
    pub fn ZSTD_freeCCtx(cctx: *mut ZSTD_CCtx) -> usize;
}
extern "C" {
    #[doc = " ZSTD_compressCCtx() :"]
    #[doc = "  Same as ZSTD_compress(), using an explicit ZSTD_CCtx"]
    #[doc = "  The function will compress at requested compression level,"]
    #[doc = "  ignoring any other parameter"]
    pub fn ZSTD_compressCCtx(
        cctx: *mut ZSTD_CCtx,
        dst: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        src: *const ::std::os::raw::c_void,
        srcSize: usize,
        compressionLevel: ::std::os::raw::c_int,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_DCtx_s {
    _unused: [u8; 0],
}
pub type ZSTD_DCtx = ZSTD_DCtx_s;
extern "C" {
    pub fn ZSTD_createDCtx() -> *mut ZSTD_DCtx;
}
extern "C" {
    pub fn ZSTD_freeDCtx(dctx: *mut ZSTD_DCtx) -> usize;
}
extern "C" {
    #[doc = " ZSTD_decompressDCtx() :"]
    #[doc = "  Same as ZSTD_decompress(),"]
    #[doc = "  requires an allocated ZSTD_DCtx."]
    #[doc = "  Compatible with sticky parameters."]
    pub fn ZSTD_decompressDCtx(
        dctx: *mut ZSTD_DCtx,
        dst: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        src: *const ::std::os::raw::c_void,
        srcSize: usize,
    ) -> usize;
}
extern "C" {
    #[doc = "  Simple dictionary API"]
    #[doc = "  Compression at an explicit compression level using a Dictionary."]
    #[doc = "  A dictionary can be any arbitrary data segment (also called a prefix),"]
    #[doc = "  or a buffer with specified information (see dictBuilder/zdict.h)."]
    #[doc = "  Note : This function loads the dictionary, resulting in significant startup delay."]
    #[doc = "         It\'s intended for a dictionary used only once."]
    #[doc = "  Note 2 : When `dict == NULL || dictSize < 8` no dictionary is used."]
    pub fn ZSTD_compress_usingDict(
        ctx: *mut ZSTD_CCtx,
        dst: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        src: *const ::std::os::raw::c_void,
        srcSize: usize,
        dict: *const ::std::os::raw::c_void,
        dictSize: usize,
        compressionLevel: ::std::os::raw::c_int,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_decompress_usingDict() :"]
    #[doc = "  Decompression using a known Dictionary."]
    #[doc = "  Dictionary must be identical to the one used during compression."]
    #[doc = "  Note : This function loads the dictionary, resulting in significant startup delay."]
    #[doc = "         It\'s intended for a dictionary used only once."]
    #[doc = "  Note : When `dict == NULL || dictSize < 8` no dictionary is used."]
    pub fn ZSTD_decompress_usingDict(
        dctx: *mut ZSTD_DCtx,
        dst: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        src: *const ::std::os::raw::c_void,
        srcSize: usize,
        dict: *const ::std::os::raw::c_void,
        dictSize: usize,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_CDict_s {
    _unused: [u8; 0],
}
#[doc = "  Bulk processing dictionary API"]
pub type ZSTD_CDict = ZSTD_CDict_s;
extern "C" {
    #[doc = " ZSTD_createCDict() :"]
    #[doc = "  When compressing multiple messages / blocks using the same dictionary, it\'s recommended to load it only once."]
    #[doc = "  ZSTD_createCDict() will create a digested dictionary, ready to start future compression operations without startup cost."]
    #[doc = "  ZSTD_CDict can be created once and shared by multiple threads concurrently, since its usage is read-only."]
    #[doc = " `dictBuffer` can be released after ZSTD_CDict creation, because its content is copied within CDict."]
    #[doc = "  Consider experimental function `ZSTD_createCDict_byReference()` if you prefer to not duplicate `dictBuffer` content."]
    #[doc = "  Note : A ZSTD_CDict can be created from an empty dictBuffer, but it is inefficient when used to compress small data."]
    pub fn ZSTD_createCDict(
        dictBuffer: *const ::std::os::raw::c_void,
        dictSize: usize,
        compressionLevel: ::std::os::raw::c_int,
    ) -> *mut ZSTD_CDict;
}
extern "C" {
    #[doc = " ZSTD_freeCDict() :"]
    #[doc = "  Function frees memory allocated by ZSTD_createCDict()."]
    pub fn ZSTD_freeCDict(CDict: *mut ZSTD_CDict) -> usize;
}
extern "C" {
    #[doc = " ZSTD_compress_usingCDict() :"]
    #[doc = "  Compression using a digested Dictionary."]
    #[doc = "  Recommended when same dictionary is used multiple times."]
    #[doc = "  Note : compression level is _decided at dictionary creation time_,"]
    #[doc = "     and frame parameters are hardcoded (dictID=yes, contentSize=yes, checksum=no)"]
    pub fn ZSTD_compress_usingCDict(
        cctx: *mut ZSTD_CCtx,
        dst: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        src: *const ::std::os::raw::c_void,
        srcSize: usize,
        cdict: *const ZSTD_CDict,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_DDict_s {
    _unused: [u8; 0],
}
pub type ZSTD_DDict = ZSTD_DDict_s;
extern "C" {
    #[doc = " ZSTD_createDDict() :"]
    #[doc = "  Create a digested dictionary, ready to start decompression operation without startup delay."]
    #[doc = "  dictBuffer can be released after DDict creation, as its content is copied inside DDict."]
    pub fn ZSTD_createDDict(
        dictBuffer: *const ::std::os::raw::c_void,
        dictSize: usize,
    ) -> *mut ZSTD_DDict;
}
extern "C" {
    #[doc = " ZSTD_freeDDict() :"]
    #[doc = "  Function frees memory allocated with ZSTD_createDDict()"]
    pub fn ZSTD_freeDDict(ddict: *mut ZSTD_DDict) -> usize;
}
extern "C" {
    #[doc = " ZSTD_decompress_usingDDict() :"]
    #[doc = "  Decompression using a digested Dictionary."]
    #[doc = "  Recommended when same dictionary is used multiple times."]
    pub fn ZSTD_decompress_usingDDict(
        dctx: *mut ZSTD_DCtx,
        dst: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        src: *const ::std::os::raw::c_void,
        srcSize: usize,
        ddict: *const ZSTD_DDict,
    ) -> usize;
}
#[doc = "  Streaming"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_inBuffer_s {
    #[doc = "< start of input buffer"]
    pub src: *const ::std::os::raw::c_void,
    #[doc = "< size of input buffer"]
    pub size: usize,
    #[doc = "< position where reading stopped. Will be updated. Necessarily 0 <= pos <= size"]
    pub pos: usize,
}
#[test]
fn bindgen_test_layout_ZSTD_inBuffer_s() {
    assert_eq!(
        ::core::mem::size_of::<ZSTD_inBuffer_s>(),
        24usize,
        concat!("Size of: ", stringify!(ZSTD_inBuffer_s))
    );
    assert_eq!(
        ::core::mem::align_of::<ZSTD_inBuffer_s>(),
        8usize,
        concat!("Alignment of ", stringify!(ZSTD_inBuffer_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_inBuffer_s>())).src as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_inBuffer_s),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_inBuffer_s>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_inBuffer_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_inBuffer_s>())).pos as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_inBuffer_s),
            "::",
            stringify!(pos)
        )
    );
}
pub type ZSTD_inBuffer = ZSTD_inBuffer_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_outBuffer_s {
    #[doc = "< start of output buffer"]
    pub dst: *mut ::std::os::raw::c_void,
    #[doc = "< size of output buffer"]
    pub size: usize,
    #[doc = "< position where writing stopped. Will be updated. Necessarily 0 <= pos <= size"]
    pub pos: usize,
}
#[test]
fn bindgen_test_layout_ZSTD_outBuffer_s() {
    assert_eq!(
        ::core::mem::size_of::<ZSTD_outBuffer_s>(),
        24usize,
        concat!("Size of: ", stringify!(ZSTD_outBuffer_s))
    );
    assert_eq!(
        ::core::mem::align_of::<ZSTD_outBuffer_s>(),
        8usize,
        concat!("Alignment of ", stringify!(ZSTD_outBuffer_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_outBuffer_s>())).dst as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_outBuffer_s),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_outBuffer_s>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_outBuffer_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_outBuffer_s>())).pos as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_outBuffer_s),
            "::",
            stringify!(pos)
        )
    );
}
pub type ZSTD_outBuffer = ZSTD_outBuffer_s;
pub type ZSTD_CStream = ZSTD_CCtx;
extern "C" {
    pub fn ZSTD_createCStream() -> *mut ZSTD_CStream;
}
extern "C" {
    pub fn ZSTD_freeCStream(zcs: *mut ZSTD_CStream) -> usize;
}
extern "C" {
    pub fn ZSTD_initCStream(
        zcs: *mut ZSTD_CStream,
        compressionLevel: ::std::os::raw::c_int,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_compressStream(
        zcs: *mut ZSTD_CStream,
        output: *mut ZSTD_outBuffer,
        input: *mut ZSTD_inBuffer,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_flushStream(
        zcs: *mut ZSTD_CStream,
        output: *mut ZSTD_outBuffer,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_endStream(
        zcs: *mut ZSTD_CStream,
        output: *mut ZSTD_outBuffer,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_CStreamInSize() -> usize;
}
extern "C" {
    pub fn ZSTD_CStreamOutSize() -> usize;
}
pub type ZSTD_DStream = ZSTD_DCtx;
extern "C" {
    pub fn ZSTD_createDStream() -> *mut ZSTD_DStream;
}
extern "C" {
    pub fn ZSTD_freeDStream(zds: *mut ZSTD_DStream) -> usize;
}
extern "C" {
    pub fn ZSTD_initDStream(zds: *mut ZSTD_DStream) -> usize;
}
extern "C" {
    pub fn ZSTD_decompressStream(
        zds: *mut ZSTD_DStream,
        output: *mut ZSTD_outBuffer,
        input: *mut ZSTD_inBuffer,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_DStreamInSize() -> usize;
}
extern "C" {
    pub fn ZSTD_DStreamOutSize() -> usize;
}
extern "C" {
    #[doc = " ZDICT_trainFromBuffer():"]
    #[doc = "  Train a dictionary from an array of samples."]
    #[doc = "  Redirect towards ZDICT_optimizeTrainFromBuffer_fastCover() single-threaded, with d=8, steps=4,"]
    #[doc = "  f=20, and accel=1."]
    #[doc = "  Samples must be stored concatenated in a single flat buffer `samplesBuffer`,"]
    #[doc = "  supplied with an array of sizes `samplesSizes`, providing the size of each sample, in order."]
    #[doc = "  The resulting dictionary will be saved into `dictBuffer`."]
    #[doc = " @return: size of dictionary stored into `dictBuffer` (<= `dictBufferCapacity`)"]
    #[doc = "          or an error code, which can be tested with ZDICT_isError()."]
    #[doc = "  Note: ZDICT_trainFromBuffer() requires about 9 bytes of memory for each input byte."]
    #[doc = "  Tips: In general, a reasonable dictionary has a size of ~ 100 KB."]
    #[doc = "        It\'s possible to select smaller or larger size, just by specifying `dictBufferCapacity`."]
    #[doc = "        In general, it\'s recommended to provide a few thousands samples, though this can vary a lot."]
    #[doc = "        It\'s recommended that total size of all samples be about ~x100 times the target size of dictionary."]
    pub fn ZDICT_trainFromBuffer(
        dictBuffer: *mut ::std::os::raw::c_void,
        dictBufferCapacity: usize,
        samplesBuffer: *const ::std::os::raw::c_void,
        samplesSizes: *const usize,
        nbSamples: ::std::os::raw::c_uint,
    ) -> usize;
}
extern "C" {
    pub fn ZDICT_getDictID(
        dictBuffer: *const ::std::os::raw::c_void,
        dictSize: usize,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ZDICT_isError(errorCode: usize) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ZDICT_getErrorName(
        errorCode: usize,
    ) -> *const ::std::os::raw::c_char;
}
