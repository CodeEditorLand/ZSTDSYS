/* automatically generated by rust-bindgen */

pub const ZSTD_VERSION_MAJOR: u32 = 1;
pub const ZSTD_VERSION_MINOR: u32 = 3;
pub const ZSTD_VERSION_RELEASE: u32 = 7;
pub const ZSTD_VERSION_NUMBER: u32 = 10307;
pub const ZSTD_CLEVEL_DEFAULT: u32 = 3;
pub const ZSTD_CONTENTSIZE_UNKNOWN: i32 = -1;
pub const ZSTD_CONTENTSIZE_ERROR: i32 = -2;
pub const ZSTD_MAGICNUMBER: u32 = 4247762216;
pub const ZSTD_MAGIC_DICTIONARY: u32 = 3962610743;
pub const ZSTD_MAGIC_SKIPPABLE_START: u32 = 407710288;
pub const ZSTD_BLOCKSIZELOG_MAX: u32 = 17;
pub const ZSTD_BLOCKSIZE_MAX: u32 = 131072;
pub const ZSTD_WINDOWLOG_MAX_32: u32 = 30;
pub const ZSTD_WINDOWLOG_MAX_64: u32 = 31;
pub const ZSTD_WINDOWLOG_MIN: u32 = 10;
pub const ZSTD_HASHLOG_MIN: u32 = 6;
pub const ZSTD_CHAINLOG_MAX_32: u32 = 29;
pub const ZSTD_CHAINLOG_MAX_64: u32 = 30;
pub const ZSTD_CHAINLOG_MIN: u32 = 6;
pub const ZSTD_HASHLOG3_MAX: u32 = 17;
pub const ZSTD_SEARCHLOG_MIN: u32 = 1;
pub const ZSTD_SEARCHLENGTH_MAX: u32 = 7;
pub const ZSTD_SEARCHLENGTH_MIN: u32 = 3;
pub const ZSTD_TARGETLENGTH_MAX: u32 = 131072;
pub const ZSTD_TARGETLENGTH_MIN: u32 = 0;
pub const ZSTD_LDM_MINMATCH_MAX: u32 = 4096;
pub const ZSTD_LDM_MINMATCH_MIN: u32 = 4;
pub const ZSTD_LDM_BUCKETSIZELOG_MAX: u32 = 8;
pub const ZSTD_FRAMEHEADERSIZE_PREFIX: u32 = 5;
pub const ZSTD_FRAMEHEADERSIZE_MIN: u32 = 6;
pub const ZSTD_FRAMEHEADERSIZE_MAX: u32 = 18;
pub const ZSTDMT_JOBSIZE_MIN: u32 = 1048576;
pub type wchar_t = libc::c_int;
extern "C" {
    pub fn ZSTD_versionNumber() -> libc::c_uint;
}
extern "C" {
    pub fn ZSTD_versionString() -> *const libc::c_char;
}
extern "C" {
    #[doc = "  Simple API"]
    #[doc = "  Compresses `src` content as a single zstd compressed frame into already allocated `dst`."]
    #[doc = "  Hint : compression runs faster if `dstCapacity` >=  `ZSTD_compressBound(srcSize)`."]
    #[doc = "  @return : compressed size written into `dst` (<= `dstCapacity),"]
    #[doc = "            or an error code if it fails (which can be tested using ZSTD_isError())."]
    pub fn ZSTD_compress(
        dst: *mut libc::c_void,
        dstCapacity: usize,
        src: *const libc::c_void,
        srcSize: usize,
        compressionLevel: libc::c_int,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_decompress() :"]
    #[doc = "  `compressedSize` : must be the _exact_ size of some number of compressed and/or skippable frames."]
    #[doc = "  `dstCapacity` is an upper bound of originalSize to regenerate."]
    #[doc = "  If user cannot imply a maximum upper bound, it\'s better to use streaming mode to decompress data."]
    #[doc = "  @return : the number of bytes decompressed into `dst` (<= `dstCapacity`),"]
    #[doc = "            or an errorCode if it fails (which can be tested using ZSTD_isError())."]
    pub fn ZSTD_decompress(
        dst: *mut libc::c_void,
        dstCapacity: usize,
        src: *const libc::c_void,
        compressedSize: usize,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_getFrameContentSize(
        src: *const libc::c_void,
        srcSize: usize,
    ) -> libc::c_ulonglong;
}
extern "C" {
    #[doc = " ZSTD_getDecompressedSize() :"]
    #[doc = "  NOTE: This function is now obsolete, in favor of ZSTD_getFrameContentSize()."]
    #[doc = "  Both functions work the same way, but ZSTD_getDecompressedSize() blends"]
    #[doc = "  \"empty\", \"unknown\" and \"error\" results to the same return value (0),"]
    #[doc = "  while ZSTD_getFrameContentSize() gives them separate return values."]
    #[doc = " @return : decompressed size of `src` frame content _if known and not empty_, 0 otherwise."]
    pub fn ZSTD_getDecompressedSize(
        src: *const libc::c_void,
        srcSize: usize,
    ) -> libc::c_ulonglong;
}
extern "C" {
    pub fn ZSTD_compressBound(srcSize: usize) -> usize;
}
extern "C" {
    pub fn ZSTD_isError(code: usize) -> libc::c_uint;
}
extern "C" {
    pub fn ZSTD_getErrorName(code: usize) -> *const libc::c_char;
}
extern "C" {
    pub fn ZSTD_maxCLevel() -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_CCtx_s {
    _unused: [u8; 0],
}
#[doc = "  Explicit context"]
pub type ZSTD_CCtx = ZSTD_CCtx_s;
extern "C" {
    pub fn ZSTD_createCCtx() -> *mut ZSTD_CCtx;
}
extern "C" {
    pub fn ZSTD_freeCCtx(cctx: *mut ZSTD_CCtx) -> usize;
}
extern "C" {
    #[doc = " ZSTD_compressCCtx() :"]
    #[doc = "  Same as ZSTD_compress(), requires an allocated ZSTD_CCtx (see ZSTD_createCCtx())."]
    pub fn ZSTD_compressCCtx(
        ctx: *mut ZSTD_CCtx,
        dst: *mut libc::c_void,
        dstCapacity: usize,
        src: *const libc::c_void,
        srcSize: usize,
        compressionLevel: libc::c_int,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_DCtx_s {
    _unused: [u8; 0],
}
pub type ZSTD_DCtx = ZSTD_DCtx_s;
extern "C" {
    pub fn ZSTD_createDCtx() -> *mut ZSTD_DCtx;
}
extern "C" {
    pub fn ZSTD_freeDCtx(dctx: *mut ZSTD_DCtx) -> usize;
}
extern "C" {
    #[doc = " ZSTD_decompressDCtx() :"]
    #[doc = "  Same as ZSTD_decompress(), requires an allocated ZSTD_DCtx (see ZSTD_createDCtx())"]
    pub fn ZSTD_decompressDCtx(
        ctx: *mut ZSTD_DCtx,
        dst: *mut libc::c_void,
        dstCapacity: usize,
        src: *const libc::c_void,
        srcSize: usize,
    ) -> usize;
}
extern "C" {
    #[doc = "  Simple dictionary API"]
    #[doc = "  Compression using a predefined Dictionary (see dictBuilder/zdict.h)."]
    #[doc = "  Note : This function loads the dictionary, resulting in significant startup delay."]
    #[doc = "  Note : When `dict == NULL || dictSize < 8` no dictionary is used."]
    pub fn ZSTD_compress_usingDict(
        ctx: *mut ZSTD_CCtx,
        dst: *mut libc::c_void,
        dstCapacity: usize,
        src: *const libc::c_void,
        srcSize: usize,
        dict: *const libc::c_void,
        dictSize: usize,
        compressionLevel: libc::c_int,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_decompress_usingDict() :"]
    #[doc = "  Decompression using a predefined Dictionary (see dictBuilder/zdict.h)."]
    #[doc = "  Dictionary must be identical to the one used during compression."]
    #[doc = "  Note : This function loads the dictionary, resulting in significant startup delay."]
    #[doc = "  Note : When `dict == NULL || dictSize < 8` no dictionary is used."]
    pub fn ZSTD_decompress_usingDict(
        dctx: *mut ZSTD_DCtx,
        dst: *mut libc::c_void,
        dstCapacity: usize,
        src: *const libc::c_void,
        srcSize: usize,
        dict: *const libc::c_void,
        dictSize: usize,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_CDict_s {
    _unused: [u8; 0],
}
#[doc = "  Bulk processing dictionary API"]
pub type ZSTD_CDict = ZSTD_CDict_s;
extern "C" {
    #[doc = " ZSTD_createCDict() :"]
    #[doc = "  When compressing multiple messages / blocks with the same dictionary, it\'s recommended to load it just once."]
    #[doc = "  ZSTD_createCDict() will create a digested dictionary, ready to start future compression operations without startup delay."]
    #[doc = "  ZSTD_CDict can be created once and shared by multiple threads concurrently, since its usage is read-only."]
    #[doc = "  `dictBuffer` can be released after ZSTD_CDict creation, since its content is copied within CDict"]
    #[doc = "  Note : A ZSTD_CDict can be created with an empty dictionary, but it is inefficient for small data."]
    pub fn ZSTD_createCDict(
        dictBuffer: *const libc::c_void,
        dictSize: usize,
        compressionLevel: libc::c_int,
    ) -> *mut ZSTD_CDict;
}
extern "C" {
    #[doc = " ZSTD_freeCDict() :"]
    #[doc = "  Function frees memory allocated by ZSTD_createCDict()."]
    pub fn ZSTD_freeCDict(CDict: *mut ZSTD_CDict) -> usize;
}
extern "C" {
    #[doc = " ZSTD_compress_usingCDict() :"]
    #[doc = "  Compression using a digested Dictionary."]
    #[doc = "  Faster startup than ZSTD_compress_usingDict(), recommended when same dictionary is used multiple times."]
    #[doc = "  Note that compression level is decided during dictionary creation."]
    #[doc = "  Frame parameters are hardcoded (dictID=yes, contentSize=yes, checksum=no)"]
    #[doc = "  Note : ZSTD_compress_usingCDict() can be used with a ZSTD_CDict created from an empty dictionary."]
    #[doc = "         But it is inefficient for small data, and it is recommended to use ZSTD_compressCCtx()."]
    pub fn ZSTD_compress_usingCDict(
        cctx: *mut ZSTD_CCtx,
        dst: *mut libc::c_void,
        dstCapacity: usize,
        src: *const libc::c_void,
        srcSize: usize,
        cdict: *const ZSTD_CDict,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_DDict_s {
    _unused: [u8; 0],
}
pub type ZSTD_DDict = ZSTD_DDict_s;
extern "C" {
    #[doc = " ZSTD_createDDict() :"]
    #[doc = "  Create a digested dictionary, ready to start decompression operation without startup delay."]
    #[doc = "  dictBuffer can be released after DDict creation, as its content is copied inside DDict"]
    pub fn ZSTD_createDDict(
        dictBuffer: *const libc::c_void,
        dictSize: usize,
    ) -> *mut ZSTD_DDict;
}
extern "C" {
    #[doc = " ZSTD_freeDDict() :"]
    #[doc = "  Function frees memory allocated with ZSTD_createDDict()"]
    pub fn ZSTD_freeDDict(ddict: *mut ZSTD_DDict) -> usize;
}
extern "C" {
    #[doc = " ZSTD_decompress_usingDDict() :"]
    #[doc = "  Decompression using a digested Dictionary."]
    #[doc = "  Faster startup than ZSTD_decompress_usingDict(), recommended when same dictionary is used multiple times."]
    pub fn ZSTD_decompress_usingDDict(
        dctx: *mut ZSTD_DCtx,
        dst: *mut libc::c_void,
        dstCapacity: usize,
        src: *const libc::c_void,
        srcSize: usize,
        ddict: *const ZSTD_DDict,
    ) -> usize;
}
#[doc = "  Streaming"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_inBuffer_s {
    #[doc = "< start of input buffer"]
    pub src: *const libc::c_void,
    #[doc = "< size of input buffer"]
    pub size: usize,
    #[doc = "< position where reading stopped. Will be updated. Necessarily 0 <= pos <= size"]
    pub pos: usize,
}
#[test]
fn bindgen_test_layout_ZSTD_inBuffer_s() {
    assert_eq!(
        ::core::mem::size_of::<ZSTD_inBuffer_s>(),
        24usize,
        concat!("Size of: ", stringify!(ZSTD_inBuffer_s))
    );
    assert_eq!(
        ::core::mem::align_of::<ZSTD_inBuffer_s>(),
        8usize,
        concat!("Alignment of ", stringify!(ZSTD_inBuffer_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_inBuffer_s>())).src as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_inBuffer_s),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_inBuffer_s>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_inBuffer_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_inBuffer_s>())).pos as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_inBuffer_s),
            "::",
            stringify!(pos)
        )
    );
}
pub type ZSTD_inBuffer = ZSTD_inBuffer_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_outBuffer_s {
    #[doc = "< start of output buffer"]
    pub dst: *mut libc::c_void,
    #[doc = "< size of output buffer"]
    pub size: usize,
    #[doc = "< position where writing stopped. Will be updated. Necessarily 0 <= pos <= size"]
    pub pos: usize,
}
#[test]
fn bindgen_test_layout_ZSTD_outBuffer_s() {
    assert_eq!(
        ::core::mem::size_of::<ZSTD_outBuffer_s>(),
        24usize,
        concat!("Size of: ", stringify!(ZSTD_outBuffer_s))
    );
    assert_eq!(
        ::core::mem::align_of::<ZSTD_outBuffer_s>(),
        8usize,
        concat!("Alignment of ", stringify!(ZSTD_outBuffer_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_outBuffer_s>())).dst as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_outBuffer_s),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_outBuffer_s>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_outBuffer_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_outBuffer_s>())).pos as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_outBuffer_s),
            "::",
            stringify!(pos)
        )
    );
}
pub type ZSTD_outBuffer = ZSTD_outBuffer_s;
pub type ZSTD_CStream = ZSTD_CCtx;
extern "C" {
    pub fn ZSTD_createCStream() -> *mut ZSTD_CStream;
}
extern "C" {
    pub fn ZSTD_freeCStream(zcs: *mut ZSTD_CStream) -> usize;
}
extern "C" {
    pub fn ZSTD_initCStream(
        zcs: *mut ZSTD_CStream,
        compressionLevel: libc::c_int,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_compressStream(
        zcs: *mut ZSTD_CStream,
        output: *mut ZSTD_outBuffer,
        input: *mut ZSTD_inBuffer,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_flushStream(
        zcs: *mut ZSTD_CStream,
        output: *mut ZSTD_outBuffer,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_endStream(
        zcs: *mut ZSTD_CStream,
        output: *mut ZSTD_outBuffer,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_CStreamInSize() -> usize;
}
extern "C" {
    pub fn ZSTD_CStreamOutSize() -> usize;
}
pub type ZSTD_DStream = ZSTD_DCtx;
extern "C" {
    pub fn ZSTD_createDStream() -> *mut ZSTD_DStream;
}
extern "C" {
    pub fn ZSTD_freeDStream(zds: *mut ZSTD_DStream) -> usize;
}
extern "C" {
    pub fn ZSTD_initDStream(zds: *mut ZSTD_DStream) -> usize;
}
extern "C" {
    pub fn ZSTD_decompressStream(
        zds: *mut ZSTD_DStream,
        output: *mut ZSTD_outBuffer,
        input: *mut ZSTD_inBuffer,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_DStreamInSize() -> usize;
}
extern "C" {
    pub fn ZSTD_DStreamOutSize() -> usize;
}
extern "C" {
    #[doc = "   ADVANCED AND EXPERIMENTAL FUNCTIONS"]
    #[doc = ""]
    #[doc = " The definitions in this section are considered experimental."]
    #[doc = " They should never be used with a dynamic library, as prototypes may change in the future."]
    #[doc = " They are provided for advanced scenarios."]
    #[doc = " Use them only in association with static linking."]
    pub fn ZSTD_minCLevel() -> libc::c_int;
}
pub const ZSTD_frameHeaderSize_prefix: usize = 5;
pub const ZSTD_frameHeaderSize_min: usize = 6;
pub const ZSTD_frameHeaderSize_max: usize = 18;
pub const ZSTD_skippableHeaderSize: usize = 8;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ZSTD_strategy {
    ZSTD_fast = 1,
    ZSTD_dfast = 2,
    ZSTD_greedy = 3,
    ZSTD_lazy = 4,
    ZSTD_lazy2 = 5,
    ZSTD_btlazy2 = 6,
    ZSTD_btopt = 7,
    ZSTD_btultra = 8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_compressionParameters {
    #[doc = "< largest match distance : larger == more compression, more memory needed during decompression"]
    pub windowLog: libc::c_uint,
    #[doc = "< fully searched segment : larger == more compression, slower, more memory (useless for fast)"]
    pub chainLog: libc::c_uint,
    #[doc = "< dispatch table : larger == faster, more memory"]
    pub hashLog: libc::c_uint,
    #[doc = "< nb of searches : larger == more compression, slower"]
    pub searchLog: libc::c_uint,
    #[doc = "< match length searched : larger == faster decompression, sometimes less compression"]
    pub searchLength: libc::c_uint,
    #[doc = "< acceptable match size for optimal parser (only) : larger == more compression, slower"]
    pub targetLength: libc::c_uint,
    pub strategy: ZSTD_strategy,
}
#[test]
fn bindgen_test_layout_ZSTD_compressionParameters() {
    assert_eq!(
        ::core::mem::size_of::<ZSTD_compressionParameters>(),
        28usize,
        concat!("Size of: ", stringify!(ZSTD_compressionParameters))
    );
    assert_eq!(
        ::core::mem::align_of::<ZSTD_compressionParameters>(),
        4usize,
        concat!("Alignment of ", stringify!(ZSTD_compressionParameters))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_compressionParameters>())).windowLog
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_compressionParameters),
            "::",
            stringify!(windowLog)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_compressionParameters>())).chainLog
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_compressionParameters),
            "::",
            stringify!(chainLog)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_compressionParameters>())).hashLog
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_compressionParameters),
            "::",
            stringify!(hashLog)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_compressionParameters>())).searchLog
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_compressionParameters),
            "::",
            stringify!(searchLog)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_compressionParameters>()))
                .searchLength as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_compressionParameters),
            "::",
            stringify!(searchLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_compressionParameters>()))
                .targetLength as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_compressionParameters),
            "::",
            stringify!(targetLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_compressionParameters>())).strategy
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_compressionParameters),
            "::",
            stringify!(strategy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_frameParameters {
    #[doc = "< 1: content size will be in frame header (when known)"]
    pub contentSizeFlag: libc::c_uint,
    #[doc = "< 1: generate a 32-bits checksum at end of frame, for error detection"]
    pub checksumFlag: libc::c_uint,
    #[doc = "< 1: no dictID will be saved into frame header (if dictionary compression)"]
    pub noDictIDFlag: libc::c_uint,
}
#[test]
fn bindgen_test_layout_ZSTD_frameParameters() {
    assert_eq!(
        ::core::mem::size_of::<ZSTD_frameParameters>(),
        12usize,
        concat!("Size of: ", stringify!(ZSTD_frameParameters))
    );
    assert_eq!(
        ::core::mem::align_of::<ZSTD_frameParameters>(),
        4usize,
        concat!("Alignment of ", stringify!(ZSTD_frameParameters))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_frameParameters>())).contentSizeFlag
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_frameParameters),
            "::",
            stringify!(contentSizeFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_frameParameters>())).checksumFlag
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_frameParameters),
            "::",
            stringify!(checksumFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_frameParameters>())).noDictIDFlag
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_frameParameters),
            "::",
            stringify!(noDictIDFlag)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_parameters {
    pub cParams: ZSTD_compressionParameters,
    pub fParams: ZSTD_frameParameters,
}
#[test]
fn bindgen_test_layout_ZSTD_parameters() {
    assert_eq!(
        ::core::mem::size_of::<ZSTD_parameters>(),
        40usize,
        concat!("Size of: ", stringify!(ZSTD_parameters))
    );
    assert_eq!(
        ::core::mem::align_of::<ZSTD_parameters>(),
        4usize,
        concat!("Alignment of ", stringify!(ZSTD_parameters))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_parameters>())).cParams as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_parameters),
            "::",
            stringify!(cParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_parameters>())).fParams as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_parameters),
            "::",
            stringify!(fParams)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_CCtx_params_s {
    _unused: [u8; 0],
}
pub type ZSTD_CCtx_params = ZSTD_CCtx_params_s;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ZSTD_dictContentType_e {
    ZSTD_dct_auto = 0,
    ZSTD_dct_rawContent = 1,
    ZSTD_dct_fullDict = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ZSTD_dictLoadMethod_e {
    #[doc = "< Copy dictionary content internally"]
    ZSTD_dlm_byCopy = 0,
    #[doc = "< Reference dictionary content -- the dictionary buffer must outlive its users."]
    ZSTD_dlm_byRef = 1,
}
extern "C" {
    #[doc = " ZSTD_findFrameCompressedSize() :"]
    #[doc = "  `src` should point to the start of a ZSTD encoded frame or skippable frame"]
    #[doc = "  `srcSize` must be >= first frame size"]
    #[doc = "  @return : the compressed size of the first frame starting at `src`,"]
    #[doc = "            suitable to pass to `ZSTD_decompress` or similar,"]
    #[doc = "            or an error code if input is invalid"]
    pub fn ZSTD_findFrameCompressedSize(
        src: *const libc::c_void,
        srcSize: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_findDecompressedSize() :"]
    #[doc = "  `src` should point the start of a series of ZSTD encoded and/or skippable frames"]
    #[doc = "  `srcSize` must be the _exact_ size of this series"]
    #[doc = "       (i.e. there should be a frame boundary exactly at `srcSize` bytes after `src`)"]
    #[doc = "  @return : - decompressed size of all data in all successive frames"]
    #[doc = "            - if the decompressed size cannot be determined: ZSTD_CONTENTSIZE_UNKNOWN"]
    #[doc = "            - if an error occurred: ZSTD_CONTENTSIZE_ERROR"]
    #[doc = ""]
    #[doc = "   note 1 : decompressed size is an optional field, that may not be present, especially in streaming mode."]
    #[doc = "            When `return==ZSTD_CONTENTSIZE_UNKNOWN`, data to decompress could be any size."]
    #[doc = "            In which case, it\'s necessary to use streaming mode to decompress data."]
    #[doc = "   note 2 : decompressed size is always present when compression is done with ZSTD_compress()"]
    #[doc = "   note 3 : decompressed size can be very large (64-bits value),"]
    #[doc = "            potentially larger than what local system can handle as a single memory segment."]
    #[doc = "            In which case, it\'s necessary to use streaming mode to decompress data."]
    #[doc = "   note 4 : If source is untrusted, decompressed size could be wrong or intentionally modified."]
    #[doc = "            Always ensure result fits within application\'s authorized limits."]
    #[doc = "            Each application can set its own limits."]
    #[doc = "   note 5 : ZSTD_findDecompressedSize handles multiple frames, and so it must traverse the input to"]
    #[doc = "            read each contained frame header.  This is fast as most of the data is skipped,"]
    #[doc = "            however it does mean that all frame data must be present and valid."]
    pub fn ZSTD_findDecompressedSize(
        src: *const libc::c_void,
        srcSize: usize,
    ) -> libc::c_ulonglong;
}
extern "C" {
    #[doc = " ZSTD_frameHeaderSize() :"]
    #[doc = "  srcSize must be >= ZSTD_frameHeaderSize_prefix."]
    #[doc = " @return : size of the Frame Header,"]
    #[doc = "           or an error code (if srcSize is too small)"]
    pub fn ZSTD_frameHeaderSize(
        src: *const libc::c_void,
        srcSize: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_sizeof_*() :"]
    #[doc = "  These functions give the current memory usage of selected object."]
    #[doc = "  Object memory usage can evolve when re-used."]
    pub fn ZSTD_sizeof_CCtx(cctx: *const ZSTD_CCtx) -> usize;
}
extern "C" {
    pub fn ZSTD_sizeof_DCtx(dctx: *const ZSTD_DCtx) -> usize;
}
extern "C" {
    pub fn ZSTD_sizeof_CStream(zcs: *const ZSTD_CStream) -> usize;
}
extern "C" {
    pub fn ZSTD_sizeof_DStream(zds: *const ZSTD_DStream) -> usize;
}
extern "C" {
    pub fn ZSTD_sizeof_CDict(cdict: *const ZSTD_CDict) -> usize;
}
extern "C" {
    pub fn ZSTD_sizeof_DDict(ddict: *const ZSTD_DDict) -> usize;
}
extern "C" {
    #[doc = " ZSTD_estimate*() :"]
    #[doc = "  These functions make it possible to estimate memory usage"]
    #[doc = "  of a future {D,C}Ctx, before its creation."]
    #[doc = "  ZSTD_estimateCCtxSize() will provide a budget large enough for any compression level up to selected one."]
    #[doc = "  It will also consider src size to be arbitrarily \"large\", which is worst case."]
    #[doc = "  If srcSize is known to always be small, ZSTD_estimateCCtxSize_usingCParams() can provide a tighter estimation."]
    #[doc = "  ZSTD_estimateCCtxSize_usingCParams() can be used in tandem with ZSTD_getCParams() to create cParams from compressionLevel."]
    #[doc = "  ZSTD_estimateCCtxSize_usingCCtxParams() can be used in tandem with ZSTD_CCtxParam_setParameter(). Only single-threaded compression is supported. This function will return an error code if ZSTD_p_nbWorkers is >= 1."]
    #[doc = "  Note : CCtx size estimation is only correct for single-threaded compression."]
    pub fn ZSTD_estimateCCtxSize(compressionLevel: libc::c_int) -> usize;
}
extern "C" {
    pub fn ZSTD_estimateCCtxSize_usingCParams(
        cParams: ZSTD_compressionParameters,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_estimateCCtxSize_usingCCtxParams(
        params: *const ZSTD_CCtx_params,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_estimateDCtxSize() -> usize;
}
extern "C" {
    #[doc = " ZSTD_estimateCStreamSize() :"]
    #[doc = "  ZSTD_estimateCStreamSize() will provide a budget large enough for any compression level up to selected one."]
    #[doc = "  It will also consider src size to be arbitrarily \"large\", which is worst case."]
    #[doc = "  If srcSize is known to always be small, ZSTD_estimateCStreamSize_usingCParams() can provide a tighter estimation."]
    #[doc = "  ZSTD_estimateCStreamSize_usingCParams() can be used in tandem with ZSTD_getCParams() to create cParams from compressionLevel."]
    #[doc = "  ZSTD_estimateCStreamSize_usingCCtxParams() can be used in tandem with ZSTD_CCtxParam_setParameter(). Only single-threaded compression is supported. This function will return an error code if ZSTD_p_nbWorkers is >= 1."]
    #[doc = "  Note : CStream size estimation is only correct for single-threaded compression."]
    #[doc = "  ZSTD_DStream memory budget depends on window Size."]
    #[doc = "  This information can be passed manually, using ZSTD_estimateDStreamSize,"]
    #[doc = "  or deducted from a valid frame Header, using ZSTD_estimateDStreamSize_fromFrame();"]
    #[doc = "  Note : if streaming is init with function ZSTD_init?Stream_usingDict(),"]
    #[doc = "         an internal ?Dict will be created, which additional size is not estimated here."]
    #[doc = "         In this case, get total size by adding ZSTD_estimate?DictSize"]
    pub fn ZSTD_estimateCStreamSize(compressionLevel: libc::c_int) -> usize;
}
extern "C" {
    pub fn ZSTD_estimateCStreamSize_usingCParams(
        cParams: ZSTD_compressionParameters,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_estimateCStreamSize_usingCCtxParams(
        params: *const ZSTD_CCtx_params,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_estimateDStreamSize(windowSize: usize) -> usize;
}
extern "C" {
    pub fn ZSTD_estimateDStreamSize_fromFrame(
        src: *const libc::c_void,
        srcSize: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_estimate?DictSize() :"]
    #[doc = "  ZSTD_estimateCDictSize() will bet that src size is relatively \"small\", and content is copied, like ZSTD_createCDict()."]
    #[doc = "  ZSTD_estimateCDictSize_advanced() makes it possible to control compression parameters precisely, like ZSTD_createCDict_advanced()."]
    #[doc = "  Note : dictionaries created by reference (`ZSTD_dlm_byRef`) are logically smaller."]
    pub fn ZSTD_estimateCDictSize(
        dictSize: usize,
        compressionLevel: libc::c_int,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_estimateCDictSize_advanced(
        dictSize: usize,
        cParams: ZSTD_compressionParameters,
        dictLoadMethod: ZSTD_dictLoadMethod_e,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_estimateDDictSize(
        dictSize: usize,
        dictLoadMethod: ZSTD_dictLoadMethod_e,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_initStatic*() :"]
    #[doc = "  Initialize an object using a pre-allocated fixed-size buffer."]
    #[doc = "  workspace: The memory area to emplace the object into."]
    #[doc = "             Provided pointer *must be 8-bytes aligned*."]
    #[doc = "             Buffer must outlive object."]
    #[doc = "  workspaceSize: Use ZSTD_estimate*Size() to determine"]
    #[doc = "                 how large workspace must be to support target scenario."]
    #[doc = " @return : pointer to object (same address as workspace, just different type),"]
    #[doc = "           or NULL if error (size too small, incorrect alignment, etc.)"]
    #[doc = "  Note : zstd will never resize nor malloc() when using a static buffer."]
    #[doc = "         If the object requires more memory than available,"]
    #[doc = "         zstd will just error out (typically ZSTD_error_memory_allocation)."]
    #[doc = "  Note 2 : there is no corresponding \"free\" function."]
    #[doc = "           Since workspace is allocated externally, it must be freed externally too."]
    #[doc = "  Note 3 : cParams : use ZSTD_getCParams() to convert a compression level"]
    #[doc = "           into its associated cParams."]
    #[doc = "  Limitation 1 : currently not compatible with internal dictionary creation, triggered by"]
    #[doc = "                 ZSTD_CCtx_loadDictionary(), ZSTD_initCStream_usingDict() or ZSTD_initDStream_usingDict()."]
    #[doc = "  Limitation 2 : static cctx currently not compatible with multi-threading."]
    #[doc = "  Limitation 3 : static dctx is incompatible with legacy support."]
    pub fn ZSTD_initStaticCCtx(
        workspace: *mut libc::c_void,
        workspaceSize: usize,
    ) -> *mut ZSTD_CCtx;
}
extern "C" {
    pub fn ZSTD_initStaticCStream(
        workspace: *mut libc::c_void,
        workspaceSize: usize,
    ) -> *mut ZSTD_CStream;
}
extern "C" {
    pub fn ZSTD_initStaticDCtx(
        workspace: *mut libc::c_void,
        workspaceSize: usize,
    ) -> *mut ZSTD_DCtx;
}
extern "C" {
    pub fn ZSTD_initStaticDStream(
        workspace: *mut libc::c_void,
        workspaceSize: usize,
    ) -> *mut ZSTD_DStream;
}
extern "C" {
    pub fn ZSTD_initStaticCDict(
        workspace: *mut libc::c_void,
        workspaceSize: usize,
        dict: *const libc::c_void,
        dictSize: usize,
        dictLoadMethod: ZSTD_dictLoadMethod_e,
        dictContentType: ZSTD_dictContentType_e,
        cParams: ZSTD_compressionParameters,
    ) -> *const ZSTD_CDict;
}
extern "C" {
    pub fn ZSTD_initStaticDDict(
        workspace: *mut libc::c_void,
        workspaceSize: usize,
        dict: *const libc::c_void,
        dictSize: usize,
        dictLoadMethod: ZSTD_dictLoadMethod_e,
        dictContentType: ZSTD_dictContentType_e,
    ) -> *const ZSTD_DDict;
}
#[doc = " Custom memory allocation :"]
#[doc = "  These prototypes make it possible to pass your own allocation/free functions."]
#[doc = "  ZSTD_customMem is provided at creation time, using ZSTD_create*_advanced() variants listed below."]
#[doc = "  All allocation/free operations will be completed using these custom variants instead of regular <stdlib.h> ones."]
pub type ZSTD_allocFunction = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut libc::c_void,
        size: usize,
    ) -> *mut libc::c_void,
>;
pub type ZSTD_freeFunction = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut libc::c_void,
        address: *mut libc::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_customMem {
    pub customAlloc: ZSTD_allocFunction,
    pub customFree: ZSTD_freeFunction,
    pub opaque: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_ZSTD_customMem() {
    assert_eq!(
        ::core::mem::size_of::<ZSTD_customMem>(),
        24usize,
        concat!("Size of: ", stringify!(ZSTD_customMem))
    );
    assert_eq!(
        ::core::mem::align_of::<ZSTD_customMem>(),
        8usize,
        concat!("Alignment of ", stringify!(ZSTD_customMem))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_customMem>())).customAlloc as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_customMem),
            "::",
            stringify!(customAlloc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_customMem>())).customFree as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_customMem),
            "::",
            stringify!(customFree)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_customMem>())).opaque as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_customMem),
            "::",
            stringify!(opaque)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}ZSTD_defaultCMem"]
    pub static ZSTD_defaultCMem: ZSTD_customMem;
}
extern "C" {
    pub fn ZSTD_createCCtx_advanced(
        customMem: ZSTD_customMem,
    ) -> *mut ZSTD_CCtx;
}
extern "C" {
    pub fn ZSTD_createCStream_advanced(
        customMem: ZSTD_customMem,
    ) -> *mut ZSTD_CStream;
}
extern "C" {
    pub fn ZSTD_createDCtx_advanced(
        customMem: ZSTD_customMem,
    ) -> *mut ZSTD_DCtx;
}
extern "C" {
    pub fn ZSTD_createDStream_advanced(
        customMem: ZSTD_customMem,
    ) -> *mut ZSTD_DStream;
}
extern "C" {
    pub fn ZSTD_createCDict_advanced(
        dict: *const libc::c_void,
        dictSize: usize,
        dictLoadMethod: ZSTD_dictLoadMethod_e,
        dictContentType: ZSTD_dictContentType_e,
        cParams: ZSTD_compressionParameters,
        customMem: ZSTD_customMem,
    ) -> *mut ZSTD_CDict;
}
extern "C" {
    pub fn ZSTD_createDDict_advanced(
        dict: *const libc::c_void,
        dictSize: usize,
        dictLoadMethod: ZSTD_dictLoadMethod_e,
        dictContentType: ZSTD_dictContentType_e,
        customMem: ZSTD_customMem,
    ) -> *mut ZSTD_DDict;
}
extern "C" {
    #[doc = " ZSTD_createCDict_byReference() :"]
    #[doc = "  Create a digested dictionary for compression"]
    #[doc = "  Dictionary content is simply referenced, and therefore stays in dictBuffer."]
    #[doc = "  It is important that dictBuffer outlives CDict, it must remain read accessible throughout the lifetime of CDict"]
    pub fn ZSTD_createCDict_byReference(
        dictBuffer: *const libc::c_void,
        dictSize: usize,
        compressionLevel: libc::c_int,
    ) -> *mut ZSTD_CDict;
}
extern "C" {
    #[doc = " ZSTD_getCParams() :"]
    #[doc = "   @return ZSTD_compressionParameters structure for a selected compression level and estimated srcSize."]
    #[doc = "   `estimatedSrcSize` value is optional, select 0 if not known"]
    pub fn ZSTD_getCParams(
        compressionLevel: libc::c_int,
        estimatedSrcSize: libc::c_ulonglong,
        dictSize: usize,
    ) -> ZSTD_compressionParameters;
}
extern "C" {
    #[doc = " ZSTD_getParams() :"]
    #[doc = "   same as ZSTD_getCParams(), but @return a full `ZSTD_parameters` object instead of sub-component `ZSTD_compressionParameters`."]
    #[doc = "   All fields of `ZSTD_frameParameters` are set to default : contentSize=1, checksum=0, noDictID=0"]
    pub fn ZSTD_getParams(
        compressionLevel: libc::c_int,
        estimatedSrcSize: libc::c_ulonglong,
        dictSize: usize,
    ) -> ZSTD_parameters;
}
extern "C" {
    #[doc = " ZSTD_checkCParams() :"]
    #[doc = "   Ensure param values remain within authorized range"]
    pub fn ZSTD_checkCParams(params: ZSTD_compressionParameters) -> usize;
}
extern "C" {
    #[doc = " ZSTD_adjustCParams() :"]
    #[doc = "  optimize params for a given `srcSize` and `dictSize`."]
    #[doc = "  both values are optional, select `0` if unknown."]
    pub fn ZSTD_adjustCParams(
        cPar: ZSTD_compressionParameters,
        srcSize: libc::c_ulonglong,
        dictSize: usize,
    ) -> ZSTD_compressionParameters;
}
extern "C" {
    #[doc = " ZSTD_compress_advanced() :"]
    #[doc = "   Same as ZSTD_compress_usingDict(), with fine-tune control over each compression parameter"]
    pub fn ZSTD_compress_advanced(
        cctx: *mut ZSTD_CCtx,
        dst: *mut libc::c_void,
        dstCapacity: usize,
        src: *const libc::c_void,
        srcSize: usize,
        dict: *const libc::c_void,
        dictSize: usize,
        params: ZSTD_parameters,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_compress_usingCDict_advanced() :"]
    #[doc = "   Same as ZSTD_compress_usingCDict(), with fine-tune control over frame parameters"]
    pub fn ZSTD_compress_usingCDict_advanced(
        cctx: *mut ZSTD_CCtx,
        dst: *mut libc::c_void,
        dstCapacity: usize,
        src: *const libc::c_void,
        srcSize: usize,
        cdict: *const ZSTD_CDict,
        fParams: ZSTD_frameParameters,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_isFrame() :"]
    #[doc = "  Tells if the content of `buffer` starts with a valid Frame Identifier."]
    #[doc = "  Note : Frame Identifier is 4 bytes. If `size < 4`, @return will always be 0."]
    #[doc = "  Note 2 : Legacy Frame Identifiers are considered valid only if Legacy Support is enabled."]
    #[doc = "  Note 3 : Skippable Frame Identifiers are considered valid."]
    pub fn ZSTD_isFrame(
        buffer: *const libc::c_void,
        size: usize,
    ) -> libc::c_uint;
}
extern "C" {
    #[doc = " ZSTD_createDDict_byReference() :"]
    #[doc = "  Create a digested dictionary, ready to start decompression operation without startup delay."]
    #[doc = "  Dictionary content is referenced, and therefore stays in dictBuffer."]
    #[doc = "  It is important that dictBuffer outlives DDict,"]
    #[doc = "  it must remain read accessible throughout the lifetime of DDict"]
    pub fn ZSTD_createDDict_byReference(
        dictBuffer: *const libc::c_void,
        dictSize: usize,
    ) -> *mut ZSTD_DDict;
}
extern "C" {
    #[doc = " ZSTD_getDictID_fromDict() :"]
    #[doc = "  Provides the dictID stored within dictionary."]
    #[doc = "  if @return == 0, the dictionary is not conformant with Zstandard specification."]
    #[doc = "  It can still be loaded, but as a content-only dictionary."]
    pub fn ZSTD_getDictID_fromDict(
        dict: *const libc::c_void,
        dictSize: usize,
    ) -> libc::c_uint;
}
extern "C" {
    #[doc = " ZSTD_getDictID_fromDDict() :"]
    #[doc = "  Provides the dictID of the dictionary loaded into `ddict`."]
    #[doc = "  If @return == 0, the dictionary is not conformant to Zstandard specification, or empty."]
    #[doc = "  Non-conformant dictionaries can still be loaded, but as content-only dictionaries."]
    pub fn ZSTD_getDictID_fromDDict(ddict: *const ZSTD_DDict) -> libc::c_uint;
}
extern "C" {
    #[doc = " ZSTD_getDictID_fromFrame() :"]
    #[doc = "  Provides the dictID required to decompressed the frame stored within `src`."]
    #[doc = "  If @return == 0, the dictID could not be decoded."]
    #[doc = "  This could for one of the following reasons :"]
    #[doc = "  - The frame does not require a dictionary to be decoded (most common case)."]
    #[doc = "  - The frame was built with dictID intentionally removed. Whatever dictionary is necessary is a hidden information."]
    #[doc = "    Note : this use case also happens when using a non-conformant dictionary."]
    #[doc = "  - `srcSize` is too small, and as a result, the frame header could not be decoded (only possible if `srcSize < ZSTD_FRAMEHEADERSIZE_MAX`)."]
    #[doc = "  - This is not a Zstandard frame."]
    #[doc = "  When identifying the exact failure cause, it\'s possible to use ZSTD_getFrameHeader(), which will provide a more precise error code."]
    pub fn ZSTD_getDictID_fromFrame(
        src: *const libc::c_void,
        srcSize: usize,
    ) -> libc::c_uint;
}
extern "C" {
    #[doc = "  Advanced streaming functions"]
    pub fn ZSTD_initCStream_srcSize(
        zcs: *mut ZSTD_CStream,
        compressionLevel: libc::c_int,
        pledgedSrcSize: libc::c_ulonglong,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_initCStream_usingDict(
        zcs: *mut ZSTD_CStream,
        dict: *const libc::c_void,
        dictSize: usize,
        compressionLevel: libc::c_int,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_initCStream_advanced(
        zcs: *mut ZSTD_CStream,
        dict: *const libc::c_void,
        dictSize: usize,
        params: ZSTD_parameters,
        pledgedSrcSize: libc::c_ulonglong,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_initCStream_usingCDict(
        zcs: *mut ZSTD_CStream,
        cdict: *const ZSTD_CDict,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_initCStream_usingCDict_advanced(
        zcs: *mut ZSTD_CStream,
        cdict: *const ZSTD_CDict,
        fParams: ZSTD_frameParameters,
        pledgedSrcSize: libc::c_ulonglong,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_resetCStream() :"]
    #[doc = "  start a new compression job, using same parameters from previous job."]
    #[doc = "  This is typically useful to skip dictionary loading stage, since it will re-use it in-place."]
    #[doc = "  Note that zcs must be init at least once before using ZSTD_resetCStream()."]
    #[doc = "  If pledgedSrcSize is not known at reset time, use macro ZSTD_CONTENTSIZE_UNKNOWN."]
    #[doc = "  If pledgedSrcSize > 0, its value must be correct, as it will be written in header, and controlled at the end."]
    #[doc = "  For the time being, pledgedSrcSize==0 is interpreted as \"srcSize unknown\" for compatibility with older programs,"]
    #[doc = "  but it will change to mean \"empty\" in future version, so use macro ZSTD_CONTENTSIZE_UNKNOWN instead."]
    #[doc = " @return : 0, or an error code (which can be tested using ZSTD_isError())"]
    pub fn ZSTD_resetCStream(
        zcs: *mut ZSTD_CStream,
        pledgedSrcSize: libc::c_ulonglong,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_frameProgression {
    pub ingested: libc::c_ulonglong,
    pub consumed: libc::c_ulonglong,
    pub produced: libc::c_ulonglong,
    pub flushed: libc::c_ulonglong,
    pub currentJobID: libc::c_uint,
    pub nbActiveWorkers: libc::c_uint,
}
#[test]
fn bindgen_test_layout_ZSTD_frameProgression() {
    assert_eq!(
        ::core::mem::size_of::<ZSTD_frameProgression>(),
        40usize,
        concat!("Size of: ", stringify!(ZSTD_frameProgression))
    );
    assert_eq!(
        ::core::mem::align_of::<ZSTD_frameProgression>(),
        8usize,
        concat!("Alignment of ", stringify!(ZSTD_frameProgression))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_frameProgression>())).ingested
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_frameProgression),
            "::",
            stringify!(ingested)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_frameProgression>())).consumed
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_frameProgression),
            "::",
            stringify!(consumed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_frameProgression>())).produced
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_frameProgression),
            "::",
            stringify!(produced)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_frameProgression>())).flushed
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_frameProgression),
            "::",
            stringify!(flushed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_frameProgression>())).currentJobID
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_frameProgression),
            "::",
            stringify!(currentJobID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_frameProgression>())).nbActiveWorkers
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_frameProgression),
            "::",
            stringify!(nbActiveWorkers)
        )
    );
}
extern "C" {
    pub fn ZSTD_getFrameProgression(
        cctx: *const ZSTD_CCtx,
    ) -> ZSTD_frameProgression;
}
extern "C" {
    #[doc = " ZSTD_toFlushNow() :"]
    #[doc = "  Tell how many bytes are ready to be flushed immediately."]
    #[doc = "  Useful for multithreading scenarios (nbWorkers >= 1)."]
    #[doc = "  Probe the oldest active job, defined as oldest job not yet entirely flushed,"]
    #[doc = "  and check its output buffer."]
    #[doc = " @return : amount of data stored in oldest job and ready to be flushed immediately."]
    #[doc = "  if @return == 0, it means either :"]
    #[doc = "  + there is no active job (could be checked with ZSTD_frameProgression()), or"]
    #[doc = "  + oldest job is still actively compressing data,"]
    #[doc = "    but everything it has produced has also been flushed so far,"]
    #[doc = "    therefore flushing speed is currently limited by production speed of oldest job"]
    #[doc = "    irrespective of the speed of concurrent newer jobs."]
    pub fn ZSTD_toFlushNow(cctx: *mut ZSTD_CCtx) -> usize;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ZSTD_DStreamParameter_e {
    DStream_p_maxWindowSize = 0,
}
extern "C" {
    pub fn ZSTD_setDStreamParameter(
        zds: *mut ZSTD_DStream,
        paramType: ZSTD_DStreamParameter_e,
        paramValue: libc::c_uint,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_initDStream_usingDict(
        zds: *mut ZSTD_DStream,
        dict: *const libc::c_void,
        dictSize: usize,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_initDStream_usingDDict(
        zds: *mut ZSTD_DStream,
        ddict: *const ZSTD_DDict,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_resetDStream(zds: *mut ZSTD_DStream) -> usize;
}
extern "C" {
    #[doc = "Buffer-less streaming compression (synchronous mode)"]
    #[doc = ""]
    #[doc = "A ZSTD_CCtx object is required to track streaming operations."]
    #[doc = "Use ZSTD_createCCtx() / ZSTD_freeCCtx() to manage resource."]
    #[doc = "ZSTD_CCtx object can be re-used multiple times within successive compression operations."]
    #[doc = ""]
    #[doc = "Start by initializing a context."]
    #[doc = "Use ZSTD_compressBegin(), or ZSTD_compressBegin_usingDict() for dictionary compression,"]
    #[doc = "or ZSTD_compressBegin_advanced(), for finer parameter control."]
    #[doc = "It\'s also possible to duplicate a reference context which has already been initialized, using ZSTD_copyCCtx()"]
    #[doc = ""]
    #[doc = "Then, consume your input using ZSTD_compressContinue()."]
    #[doc = "There are some important considerations to keep in mind when using this advanced function :"]
    #[doc = "- ZSTD_compressContinue() has no internal buffer. It uses externally provided buffers only."]
    #[doc = "- Interface is synchronous : input is consumed entirely and produces 1+ compressed blocks."]
    #[doc = "- Caller must ensure there is enough space in `dst` to store compressed data under worst case scenario."]
    #[doc = "Worst case evaluation is provided by ZSTD_compressBound()."]
    #[doc = "ZSTD_compressContinue() doesn\'t guarantee recover after a failed compression."]
    #[doc = "- ZSTD_compressContinue() presumes prior input ***is still accessible and unmodified*** (up to maximum distance size, see WindowLog)."]
    #[doc = "It remembers all previous contiguous blocks, plus one separated memory segment (which can itself consists of multiple contiguous blocks)"]
    #[doc = "- ZSTD_compressContinue() detects that prior input has been overwritten when `src` buffer overlaps."]
    #[doc = "In which case, it will \"discard\" the relevant memory section from its history."]
    #[doc = ""]
    #[doc = "Finish a frame with ZSTD_compressEnd(), which will write the last block(s) and optional checksum."]
    #[doc = "It\'s possible to use srcSize==0, in which case, it will write a final empty block to end the frame."]
    #[doc = "Without last block mark, frames are considered unfinished (hence corrupted) by compliant decoders."]
    #[doc = ""]
    #[doc = "`ZSTD_CCtx` object can be re-used (ZSTD_compressBegin()) to compress again."]
    pub fn ZSTD_compressBegin(
        cctx: *mut ZSTD_CCtx,
        compressionLevel: libc::c_int,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_compressBegin_usingDict(
        cctx: *mut ZSTD_CCtx,
        dict: *const libc::c_void,
        dictSize: usize,
        compressionLevel: libc::c_int,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_compressBegin_advanced(
        cctx: *mut ZSTD_CCtx,
        dict: *const libc::c_void,
        dictSize: usize,
        params: ZSTD_parameters,
        pledgedSrcSize: libc::c_ulonglong,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_compressBegin_usingCDict(
        cctx: *mut ZSTD_CCtx,
        cdict: *const ZSTD_CDict,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_compressBegin_usingCDict_advanced(
        cctx: *mut ZSTD_CCtx,
        cdict: *const ZSTD_CDict,
        fParams: ZSTD_frameParameters,
        pledgedSrcSize: libc::c_ulonglong,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_copyCCtx(
        cctx: *mut ZSTD_CCtx,
        preparedCCtx: *const ZSTD_CCtx,
        pledgedSrcSize: libc::c_ulonglong,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_compressContinue(
        cctx: *mut ZSTD_CCtx,
        dst: *mut libc::c_void,
        dstCapacity: usize,
        src: *const libc::c_void,
        srcSize: usize,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_compressEnd(
        cctx: *mut ZSTD_CCtx,
        dst: *mut libc::c_void,
        dstCapacity: usize,
        src: *const libc::c_void,
        srcSize: usize,
    ) -> usize;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ZSTD_frameType_e {
    ZSTD_frame = 0,
    ZSTD_skippableFrame = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_frameHeader {
    pub frameContentSize: libc::c_ulonglong,
    pub windowSize: libc::c_ulonglong,
    pub blockSizeMax: libc::c_uint,
    pub frameType: ZSTD_frameType_e,
    pub headerSize: libc::c_uint,
    pub dictID: libc::c_uint,
    pub checksumFlag: libc::c_uint,
}
#[test]
fn bindgen_test_layout_ZSTD_frameHeader() {
    assert_eq!(
        ::core::mem::size_of::<ZSTD_frameHeader>(),
        40usize,
        concat!("Size of: ", stringify!(ZSTD_frameHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<ZSTD_frameHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(ZSTD_frameHeader))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_frameHeader>())).frameContentSize
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_frameHeader),
            "::",
            stringify!(frameContentSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_frameHeader>())).windowSize
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_frameHeader),
            "::",
            stringify!(windowSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_frameHeader>())).blockSizeMax
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_frameHeader),
            "::",
            stringify!(blockSizeMax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_frameHeader>())).frameType as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_frameHeader),
            "::",
            stringify!(frameType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_frameHeader>())).headerSize
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_frameHeader),
            "::",
            stringify!(headerSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_frameHeader>())).dictID as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_frameHeader),
            "::",
            stringify!(dictID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ZSTD_frameHeader>())).checksumFlag
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ZSTD_frameHeader),
            "::",
            stringify!(checksumFlag)
        )
    );
}
extern "C" {
    #[doc = " ZSTD_getFrameHeader() :"]
    #[doc = "  decode Frame Header, or requires larger `srcSize`."]
    #[doc = " @return : 0, `zfhPtr` is correctly filled,"]
    #[doc = "          >0, `srcSize` is too small, value is wanted `srcSize` amount,"]
    #[doc = "           or an error code, which can be tested using ZSTD_isError()"]
    pub fn ZSTD_getFrameHeader(
        zfhPtr: *mut ZSTD_frameHeader,
        src: *const libc::c_void,
        srcSize: usize,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_decodingBufferSize_min(
        windowSize: libc::c_ulonglong,
        frameContentSize: libc::c_ulonglong,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_decompressBegin(dctx: *mut ZSTD_DCtx) -> usize;
}
extern "C" {
    pub fn ZSTD_decompressBegin_usingDict(
        dctx: *mut ZSTD_DCtx,
        dict: *const libc::c_void,
        dictSize: usize,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_decompressBegin_usingDDict(
        dctx: *mut ZSTD_DCtx,
        ddict: *const ZSTD_DDict,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_nextSrcSizeToDecompress(dctx: *mut ZSTD_DCtx) -> usize;
}
extern "C" {
    pub fn ZSTD_decompressContinue(
        dctx: *mut ZSTD_DCtx,
        dst: *mut libc::c_void,
        dstCapacity: usize,
        src: *const libc::c_void,
        srcSize: usize,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_copyDCtx(dctx: *mut ZSTD_DCtx, preparedDCtx: *const ZSTD_DCtx);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ZSTD_nextInputType_e {
    ZSTDnit_frameHeader = 0,
    ZSTDnit_blockHeader = 1,
    ZSTDnit_block = 2,
    ZSTDnit_lastBlock = 3,
    ZSTDnit_checksum = 4,
    ZSTDnit_skippableFrame = 5,
}
extern "C" {
    pub fn ZSTD_nextInputType(dctx: *mut ZSTD_DCtx) -> ZSTD_nextInputType_e;
}
#[repr(u32)]
#[doc = "       New advanced API (experimental)"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ZSTD_format_e {
    ZSTD_f_zstd1 = 0,
    ZSTD_f_zstd1_magicless = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ZSTD_cParameter {
    ZSTD_p_format = 10,
    ZSTD_p_compressionLevel = 100,
    ZSTD_p_windowLog = 101,
    ZSTD_p_hashLog = 102,
    ZSTD_p_chainLog = 103,
    ZSTD_p_searchLog = 104,
    ZSTD_p_minMatch = 105,
    ZSTD_p_targetLength = 106,
    ZSTD_p_compressionStrategy = 107,
    ZSTD_p_enableLongDistanceMatching = 160,
    ZSTD_p_ldmHashLog = 161,
    ZSTD_p_ldmMinMatch = 162,
    ZSTD_p_ldmBucketSizeLog = 163,
    ZSTD_p_ldmHashEveryLog = 164,
    ZSTD_p_contentSizeFlag = 200,
    ZSTD_p_checksumFlag = 201,
    ZSTD_p_dictIDFlag = 202,
    ZSTD_p_nbWorkers = 400,
    ZSTD_p_jobSize = 401,
    ZSTD_p_overlapSizeLog = 402,
    ZSTD_p_forceMaxWindow = 1100,
    ZSTD_p_forceAttachDict = 1101,
}
extern "C" {
    #[doc = " ZSTD_CCtx_setParameter() :"]
    #[doc = "  Set one compression parameter, selected by enum ZSTD_cParameter."]
    #[doc = "  Setting a parameter is generally only possible during frame initialization (before starting compression)."]
    #[doc = "  Exception : when using multi-threading mode (nbThreads >= 1),"]
    #[doc = "              following parameters can be updated _during_ compression (within same frame):"]
    #[doc = "              => compressionLevel, hashLog, chainLog, searchLog, minMatch, targetLength and strategy."]
    #[doc = "              new parameters will be active on next job, or after a flush()."]
    #[doc = "  Note : when `value` type is not unsigned (int, or enum), cast it to unsigned for proper type checking."]
    #[doc = "  @result : informational value (typically, value being set, correctly clamped),"]
    #[doc = "            or an error code (which can be tested with ZSTD_isError())."]
    pub fn ZSTD_CCtx_setParameter(
        cctx: *mut ZSTD_CCtx,
        param: ZSTD_cParameter,
        value: libc::c_uint,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_CCtx_getParameter() :"]
    #[doc = " Get the requested value of one compression parameter, selected by enum ZSTD_cParameter."]
    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
    pub fn ZSTD_CCtx_getParameter(
        cctx: *mut ZSTD_CCtx,
        param: ZSTD_cParameter,
        value: *mut libc::c_uint,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_CCtx_setPledgedSrcSize() :"]
    #[doc = "  Total input data size to be compressed as a single frame."]
    #[doc = "  This value will be controlled at the end, and result in error if not respected."]
    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
    #[doc = "  Note 1 : 0 means zero, empty."]
    #[doc = "           In order to mean \"unknown content size\", pass constant ZSTD_CONTENTSIZE_UNKNOWN."]
    #[doc = "           ZSTD_CONTENTSIZE_UNKNOWN is default value for any new compression job."]
    #[doc = "  Note 2 : If all data is provided and consumed in a single round,"]
    #[doc = "           this value is overriden by srcSize instead."]
    pub fn ZSTD_CCtx_setPledgedSrcSize(
        cctx: *mut ZSTD_CCtx,
        pledgedSrcSize: libc::c_ulonglong,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_CCtx_loadDictionary() :"]
    #[doc = "  Create an internal CDict from `dict` buffer."]
    #[doc = "  Decompression will have to use same dictionary."]
    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
    #[doc = "  Special: Adding a NULL (or 0-size) dictionary invalidates previous dictionary,"]
    #[doc = "           meaning \"return to no-dictionary mode\"."]
    #[doc = "  Note 1 : Dictionary will be used for all future compression jobs."]
    #[doc = "           To return to \"no-dictionary\" situation, load a NULL dictionary"]
    #[doc = "  Note 2 : Loading a dictionary involves building tables, which are dependent on compression parameters."]
    #[doc = "           For this reason, compression parameters cannot be changed anymore after loading a dictionary."]
    #[doc = "           It\'s also a CPU consuming operation, with non-negligible impact on latency."]
    #[doc = "  Note 3 :`dict` content will be copied internally."]
    #[doc = "           Use ZSTD_CCtx_loadDictionary_byReference() to reference dictionary content instead."]
    #[doc = "           In such a case, dictionary buffer must outlive its users."]
    #[doc = "  Note 4 : Use ZSTD_CCtx_loadDictionary_advanced()"]
    #[doc = "           to precisely select how dictionary content must be interpreted."]
    pub fn ZSTD_CCtx_loadDictionary(
        cctx: *mut ZSTD_CCtx,
        dict: *const libc::c_void,
        dictSize: usize,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_CCtx_loadDictionary_byReference(
        cctx: *mut ZSTD_CCtx,
        dict: *const libc::c_void,
        dictSize: usize,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_CCtx_loadDictionary_advanced(
        cctx: *mut ZSTD_CCtx,
        dict: *const libc::c_void,
        dictSize: usize,
        dictLoadMethod: ZSTD_dictLoadMethod_e,
        dictContentType: ZSTD_dictContentType_e,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_CCtx_refCDict() :"]
    #[doc = "  Reference a prepared dictionary, to be used for all next compression jobs."]
    #[doc = "  Note that compression parameters are enforced from within CDict,"]
    #[doc = "  and supercede any compression parameter previously set within CCtx."]
    #[doc = "  The dictionary will remain valid for future compression jobs using same CCtx."]
    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
    #[doc = "  Special : adding a NULL CDict means \"return to no-dictionary mode\"."]
    #[doc = "  Note 1 : Currently, only one dictionary can be managed."]
    #[doc = "           Adding a new dictionary effectively \"discards\" any previous one."]
    #[doc = "  Note 2 : CDict is just referenced, its lifetime must outlive CCtx."]
    pub fn ZSTD_CCtx_refCDict(
        cctx: *mut ZSTD_CCtx,
        cdict: *const ZSTD_CDict,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_CCtx_refPrefix() :"]
    #[doc = "  Reference a prefix (single-usage dictionary) for next compression job."]
    #[doc = "  Decompression will need same prefix to properly regenerate data."]
    #[doc = "  Compressing with a prefix is similar in outcome as performing a diff and compressing it,"]
    #[doc = "  but performs much faster, especially during decompression (compression speed is tunable with compression level)."]
    #[doc = "  Note that prefix is **only used once**. Tables are discarded at end of compression job (ZSTD_e_end)."]
    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
    #[doc = "  Special: Adding any prefix (including NULL) invalidates any previous prefix or dictionary"]
    #[doc = "  Note 1 : Prefix buffer is referenced. It **must** outlive compression job."]
    #[doc = "           Its contain must remain unmodified up to end of compression (ZSTD_e_end)."]
    #[doc = "  Note 2 : If the intention is to diff some large src data blob with some prior version of itself,"]
    #[doc = "           ensure that the window size is large enough to contain the entire source."]
    #[doc = "           See ZSTD_p_windowLog."]
    #[doc = "  Note 3 : Referencing a prefix involves building tables, which are dependent on compression parameters."]
    #[doc = "           It\'s a CPU consuming operation, with non-negligible impact on latency."]
    #[doc = "           If there is a need to use same prefix multiple times, consider loadDictionary instead."]
    #[doc = "  Note 4 : By default, the prefix is treated as raw content (ZSTD_dm_rawContent)."]
    #[doc = "           Use ZSTD_CCtx_refPrefix_advanced() to alter dictMode."]
    pub fn ZSTD_CCtx_refPrefix(
        cctx: *mut ZSTD_CCtx,
        prefix: *const libc::c_void,
        prefixSize: usize,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_CCtx_refPrefix_advanced(
        cctx: *mut ZSTD_CCtx,
        prefix: *const libc::c_void,
        prefixSize: usize,
        dictContentType: ZSTD_dictContentType_e,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_CCtx_reset() :"]
    #[doc = "  Return a CCtx to clean state."]
    #[doc = "  Useful after an error, or to interrupt an ongoing compression job and start a new one."]
    #[doc = "  Any internal data not yet flushed is cancelled."]
    #[doc = "  The parameters and dictionary are kept unchanged, to reset them use ZSTD_CCtx_resetParameters()."]
    pub fn ZSTD_CCtx_reset(cctx: *mut ZSTD_CCtx);
}
extern "C" {
    #[doc = " ZSTD_CCtx_resetParameters() :"]
    #[doc = "  All parameters are back to default values (compression level is ZSTD_CLEVEL_DEFAULT)."]
    #[doc = "  Dictionary (if any) is dropped."]
    #[doc = "  Resetting parameters is only possible during frame initialization (before starting compression)."]
    #[doc = "  To reset the context use ZSTD_CCtx_reset()."]
    #[doc = "  @return 0 or an error code (which can be checked with ZSTD_isError())."]
    pub fn ZSTD_CCtx_resetParameters(cctx: *mut ZSTD_CCtx) -> usize;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ZSTD_EndDirective {
    ZSTD_e_continue = 0,
    ZSTD_e_flush = 1,
    ZSTD_e_end = 2,
}
extern "C" {
    #[doc = " ZSTD_compress_generic() :"]
    #[doc = "  Behave about the same as ZSTD_compressStream. To note :"]
    #[doc = "  - Compression parameters are pushed into CCtx before starting compression, using ZSTD_CCtx_setParameter()"]
    #[doc = "  - Compression parameters cannot be changed once compression is started."]
    #[doc = "  - outpot->pos must be <= dstCapacity, input->pos must be <= srcSize"]
    #[doc = "  - outpot->pos and input->pos will be updated. They are guaranteed to remain below their respective limit."]
    #[doc = "  - In single-thread mode (default), function is blocking : it completed its job before returning to caller."]
    #[doc = "  - In multi-thread mode, function is non-blocking : it just acquires a copy of input, and distribute job to internal worker threads,"]
    #[doc = "                                                     and then immediately returns, just indicating that there is some data remaining to be flushed."]
    #[doc = "                                                     The function nonetheless guarantees forward progress : it will return only after it reads or write at least 1+ byte."]
    #[doc = "  - Exception : in multi-threading mode, if the first call requests a ZSTD_e_end directive, it is blocking : it will complete compression before giving back control to caller."]
    #[doc = "  - @return provides a minimum amount of data remaining to be flushed from internal buffers"]
    #[doc = "            or an error code, which can be tested using ZSTD_isError()."]
    #[doc = "            if @return != 0, flush is not fully completed, there is still some data left within internal buffers."]
    #[doc = "            This is useful for ZSTD_e_flush, since in this case more flushes are necessary to empty all buffers."]
    #[doc = "            For ZSTD_e_end, @return == 0 when internal buffers are fully flushed and frame is completed."]
    #[doc = "  - after a ZSTD_e_end directive, if internal buffer is not fully flushed (@return != 0),"]
    #[doc = "            only ZSTD_e_end or ZSTD_e_flush operations are allowed."]
    #[doc = "            Before starting a new compression job, or changing compression parameters,"]
    #[doc = "            it is required to fully flush internal buffers."]
    pub fn ZSTD_compress_generic(
        cctx: *mut ZSTD_CCtx,
        output: *mut ZSTD_outBuffer,
        input: *mut ZSTD_inBuffer,
        endOp: ZSTD_EndDirective,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_compress_generic_simpleArgs() :"]
    #[doc = "  Same as ZSTD_compress_generic(),"]
    #[doc = "  but using only integral types as arguments."]
    #[doc = "  Argument list is larger than ZSTD_{in,out}Buffer,"]
    #[doc = "  but can be helpful for binders from dynamic languages"]
    #[doc = "  which have troubles handling structures containing memory pointers."]
    pub fn ZSTD_compress_generic_simpleArgs(
        cctx: *mut ZSTD_CCtx,
        dst: *mut libc::c_void,
        dstCapacity: usize,
        dstPos: *mut usize,
        src: *const libc::c_void,
        srcSize: usize,
        srcPos: *mut usize,
        endOp: ZSTD_EndDirective,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_CCtx_params :"]
    #[doc = "  Quick howto :"]
    #[doc = "  - ZSTD_createCCtxParams() : Create a ZSTD_CCtx_params structure"]
    #[doc = "  - ZSTD_CCtxParam_setParameter() : Push parameters one by one into"]
    #[doc = "                                    an existing ZSTD_CCtx_params structure."]
    #[doc = "                                    This is similar to"]
    #[doc = "                                    ZSTD_CCtx_setParameter()."]
    #[doc = "  - ZSTD_CCtx_setParametersUsingCCtxParams() : Apply parameters to"]
    #[doc = "                                    an existing CCtx."]
    #[doc = "                                    These parameters will be applied to"]
    #[doc = "                                    all subsequent compression jobs."]
    #[doc = "  - ZSTD_compress_generic() : Do compression using the CCtx."]
    #[doc = "  - ZSTD_freeCCtxParams() : Free the memory."]
    #[doc = ""]
    #[doc = "  This can be used with ZSTD_estimateCCtxSize_advanced_usingCCtxParams()"]
    #[doc = "  for static allocation for single-threaded compression."]
    pub fn ZSTD_createCCtxParams() -> *mut ZSTD_CCtx_params;
}
extern "C" {
    pub fn ZSTD_freeCCtxParams(params: *mut ZSTD_CCtx_params) -> usize;
}
extern "C" {
    #[doc = " ZSTD_CCtxParams_reset() :"]
    #[doc = "  Reset params to default values."]
    pub fn ZSTD_CCtxParams_reset(params: *mut ZSTD_CCtx_params) -> usize;
}
extern "C" {
    #[doc = " ZSTD_CCtxParams_init() :"]
    #[doc = "  Initializes the compression parameters of cctxParams according to"]
    #[doc = "  compression level. All other parameters are reset to their default values."]
    pub fn ZSTD_CCtxParams_init(
        cctxParams: *mut ZSTD_CCtx_params,
        compressionLevel: libc::c_int,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_CCtxParams_init_advanced() :"]
    #[doc = "  Initializes the compression and frame parameters of cctxParams according to"]
    #[doc = "  params. All other parameters are reset to their default values."]
    pub fn ZSTD_CCtxParams_init_advanced(
        cctxParams: *mut ZSTD_CCtx_params,
        params: ZSTD_parameters,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_CCtxParam_setParameter() :"]
    #[doc = "  Similar to ZSTD_CCtx_setParameter."]
    #[doc = "  Set one compression parameter, selected by enum ZSTD_cParameter."]
    #[doc = "  Parameters must be applied to a ZSTD_CCtx using ZSTD_CCtx_setParametersUsingCCtxParams()."]
    #[doc = "  Note : when `value` is an enum, cast it to unsigned for proper type checking."]
    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
    pub fn ZSTD_CCtxParam_setParameter(
        params: *mut ZSTD_CCtx_params,
        param: ZSTD_cParameter,
        value: libc::c_uint,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_CCtxParam_getParameter() :"]
    #[doc = " Similar to ZSTD_CCtx_getParameter."]
    #[doc = " Get the requested value of one compression parameter, selected by enum ZSTD_cParameter."]
    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
    pub fn ZSTD_CCtxParam_getParameter(
        params: *mut ZSTD_CCtx_params,
        param: ZSTD_cParameter,
        value: *mut libc::c_uint,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_CCtx_setParametersUsingCCtxParams() :"]
    #[doc = "  Apply a set of ZSTD_CCtx_params to the compression context."]
    #[doc = "  This can be done even after compression is started,"]
    #[doc = "    if nbWorkers==0, this will have no impact until a new compression is started."]
    #[doc = "    if nbWorkers>=1, new parameters will be picked up at next job,"]
    #[doc = "       with a few restrictions (windowLog, pledgedSrcSize, nbWorkers, jobSize, and overlapLog are not updated)."]
    pub fn ZSTD_CCtx_setParametersUsingCCtxParams(
        cctx: *mut ZSTD_CCtx,
        params: *const ZSTD_CCtx_params,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_DCtx_loadDictionary() :"]
    #[doc = "  Create an internal DDict from dict buffer,"]
    #[doc = "  to be used to decompress next frames."]
    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
    #[doc = "  Special : Adding a NULL (or 0-size) dictionary invalidates any previous dictionary,"]
    #[doc = "            meaning \"return to no-dictionary mode\"."]
    #[doc = "  Note 1 : `dict` content will be copied internally."]
    #[doc = "            Use ZSTD_DCtx_loadDictionary_byReference()"]
    #[doc = "            to reference dictionary content instead."]
    #[doc = "            In which case, the dictionary buffer must outlive its users."]
    #[doc = "  Note 2 : Loading a dictionary involves building tables,"]
    #[doc = "           which has a non-negligible impact on CPU usage and latency."]
    #[doc = "  Note 3 : Use ZSTD_DCtx_loadDictionary_advanced() to select"]
    #[doc = "           how dictionary content will be interpreted and loaded."]
    pub fn ZSTD_DCtx_loadDictionary(
        dctx: *mut ZSTD_DCtx,
        dict: *const libc::c_void,
        dictSize: usize,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_DCtx_loadDictionary_byReference(
        dctx: *mut ZSTD_DCtx,
        dict: *const libc::c_void,
        dictSize: usize,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_DCtx_loadDictionary_advanced(
        dctx: *mut ZSTD_DCtx,
        dict: *const libc::c_void,
        dictSize: usize,
        dictLoadMethod: ZSTD_dictLoadMethod_e,
        dictContentType: ZSTD_dictContentType_e,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_DCtx_refDDict() :"]
    #[doc = "  Reference a prepared dictionary, to be used to decompress next frames."]
    #[doc = "  The dictionary remains active for decompression of future frames using same DCtx."]
    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
    #[doc = "  Note 1 : Currently, only one dictionary can be managed."]
    #[doc = "           Referencing a new dictionary effectively \"discards\" any previous one."]
    #[doc = "  Special : adding a NULL DDict means \"return to no-dictionary mode\"."]
    #[doc = "  Note 2 : DDict is just referenced, its lifetime must outlive its usage from DCtx."]
    pub fn ZSTD_DCtx_refDDict(
        dctx: *mut ZSTD_DCtx,
        ddict: *const ZSTD_DDict,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_DCtx_refPrefix() :"]
    #[doc = "  Reference a prefix (single-usage dictionary) for next compression job."]
    #[doc = "  This is the reverse operation of ZSTD_CCtx_refPrefix(),"]
    #[doc = "  and must use the same prefix as the one used during compression."]
    #[doc = "  Prefix is **only used once**. Reference is discarded at end of frame."]
    #[doc = "  End of frame is reached when ZSTD_DCtx_decompress_generic() returns 0."]
    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
    #[doc = "  Note 1 : Adding any prefix (including NULL) invalidates any previously set prefix or dictionary"]
    #[doc = "  Note 2 : Prefix buffer is referenced. It **must** outlive decompression job."]
    #[doc = "           Prefix buffer must remain unmodified up to the end of frame,"]
    #[doc = "           reached when ZSTD_DCtx_decompress_generic() returns 0."]
    #[doc = "  Note 3 : By default, the prefix is treated as raw content (ZSTD_dm_rawContent)."]
    #[doc = "           Use ZSTD_CCtx_refPrefix_advanced() to alter dictMode."]
    #[doc = "  Note 4 : Referencing a raw content prefix has almost no cpu nor memory cost."]
    #[doc = "           A fulldict prefix is more costly though."]
    pub fn ZSTD_DCtx_refPrefix(
        dctx: *mut ZSTD_DCtx,
        prefix: *const libc::c_void,
        prefixSize: usize,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_DCtx_refPrefix_advanced(
        dctx: *mut ZSTD_DCtx,
        prefix: *const libc::c_void,
        prefixSize: usize,
        dictContentType: ZSTD_dictContentType_e,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_DCtx_setMaxWindowSize() :"]
    #[doc = "  Refuses allocating internal buffers for frames requiring a window size larger than provided limit."]
    #[doc = "  This is useful to prevent a decoder context from reserving too much memory for itself (potential attack scenario)."]
    #[doc = "  This parameter is only useful in streaming mode, since no internal buffer is allocated in direct mode."]
    #[doc = "  By default, a decompression context accepts all window sizes <= (1 << ZSTD_WINDOWLOG_MAX)"]
    #[doc = " @return : 0, or an error code (which can be tested using ZSTD_isError())."]
    pub fn ZSTD_DCtx_setMaxWindowSize(
        dctx: *mut ZSTD_DCtx,
        maxWindowSize: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_DCtx_setFormat() :"]
    #[doc = "  Instruct the decoder context about what kind of data to decode next."]
    #[doc = "  This instruction is mandatory to decode data without a fully-formed header,"]
    #[doc = "  such ZSTD_f_zstd1_magicless for example."]
    #[doc = " @return : 0, or an error code (which can be tested using ZSTD_isError())."]
    pub fn ZSTD_DCtx_setFormat(
        dctx: *mut ZSTD_DCtx,
        format: ZSTD_format_e,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_getFrameHeader_advanced() :"]
    #[doc = "  same as ZSTD_getFrameHeader(),"]
    #[doc = "  with added capability to select a format (like ZSTD_f_zstd1_magicless)"]
    pub fn ZSTD_getFrameHeader_advanced(
        zfhPtr: *mut ZSTD_frameHeader,
        src: *const libc::c_void,
        srcSize: usize,
        format: ZSTD_format_e,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_decompress_generic() :"]
    #[doc = "  Behave the same as ZSTD_decompressStream."]
    #[doc = "  Decompression parameters cannot be changed once decompression is started."]
    #[doc = " @return : an error code, which can be tested using ZSTD_isError()"]
    #[doc = "           if >0, a hint, nb of expected input bytes for next invocation."]
    #[doc = "           `0` means : a frame has just been fully decoded and flushed."]
    pub fn ZSTD_decompress_generic(
        dctx: *mut ZSTD_DCtx,
        output: *mut ZSTD_outBuffer,
        input: *mut ZSTD_inBuffer,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_decompress_generic_simpleArgs() :"]
    #[doc = "  Same as ZSTD_decompress_generic(),"]
    #[doc = "  but using only integral types as arguments."]
    #[doc = "  Argument list is larger than ZSTD_{in,out}Buffer,"]
    #[doc = "  but can be helpful for binders from dynamic languages"]
    #[doc = "  which have troubles handling structures containing memory pointers."]
    pub fn ZSTD_decompress_generic_simpleArgs(
        dctx: *mut ZSTD_DCtx,
        dst: *mut libc::c_void,
        dstCapacity: usize,
        dstPos: *mut usize,
        src: *const libc::c_void,
        srcSize: usize,
        srcPos: *mut usize,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTD_DCtx_reset() :"]
    #[doc = "  Return a DCtx to clean state."]
    #[doc = "  If a decompression was ongoing, any internal data not yet flushed is cancelled."]
    #[doc = "  All parameters are back to default values, including sticky ones."]
    #[doc = "  Dictionary (if any) is dropped."]
    #[doc = "  Parameters can be modified again after a reset."]
    pub fn ZSTD_DCtx_reset(dctx: *mut ZSTD_DCtx);
}
extern "C" {
    #[doc = "Block functions produce and decode raw zstd blocks, without frame metadata."]
    #[doc = "Frame metadata cost is typically ~18 bytes, which can be non-negligible for very small blocks (< 100 bytes)."]
    #[doc = "User will have to take in charge required information to regenerate data, such as compressed and content sizes."]
    #[doc = ""]
    #[doc = "A few rules to respect :"]
    #[doc = "- Compressing and decompressing require a context structure"]
    #[doc = "+ Use ZSTD_createCCtx() and ZSTD_createDCtx()"]
    #[doc = "- It is necessary to init context before starting"]
    #[doc = "+ compression : any ZSTD_compressBegin*() variant, including with dictionary"]
    #[doc = "+ decompression : any ZSTD_decompressBegin*() variant, including with dictionary"]
    #[doc = "+ copyCCtx() and copyDCtx() can be used too"]
    #[doc = "- Block size is limited, it must be <= ZSTD_getBlockSize() <= ZSTD_BLOCKSIZE_MAX == 128 KB"]
    #[doc = "+ If input is larger than a block size, it\'s necessary to split input data into multiple blocks"]
    #[doc = "+ For inputs larger than a single block size, consider using the regular ZSTD_compress() instead."]
    #[doc = "Frame metadata is not that costly, and quickly becomes negligible as source size grows larger."]
    #[doc = "- When a block is considered not compressible enough, ZSTD_compressBlock() result will be zero."]
    #[doc = "In which case, nothing is produced into `dst`."]
    #[doc = "+ User must test for such outcome and deal directly with uncompressed data"]
    #[doc = "+ ZSTD_decompressBlock() doesn\'t accept uncompressed data as input !!!"]
    #[doc = "+ In case of multiple successive blocks, should some of them be uncompressed,"]
    #[doc = "decoder must be informed of their existence in order to follow proper history."]
    #[doc = "Use ZSTD_insertBlock() for such a case."]
    pub fn ZSTD_getBlockSize(cctx: *const ZSTD_CCtx) -> usize;
}
extern "C" {
    pub fn ZSTD_compressBlock(
        cctx: *mut ZSTD_CCtx,
        dst: *mut libc::c_void,
        dstCapacity: usize,
        src: *const libc::c_void,
        srcSize: usize,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_decompressBlock(
        dctx: *mut ZSTD_DCtx,
        dst: *mut libc::c_void,
        dstCapacity: usize,
        src: *const libc::c_void,
        srcSize: usize,
    ) -> usize;
}
extern "C" {
    pub fn ZSTD_insertBlock(
        dctx: *mut ZSTD_DCtx,
        blockStart: *const libc::c_void,
        blockSize: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " ZDICT_trainFromBuffer():"]
    #[doc = "  Train a dictionary from an array of samples."]
    #[doc = "  Redirect towards ZDICT_optimizeTrainFromBuffer_fastCover() single-threaded, with d=8, steps=4,"]
    #[doc = "  f=20, and accel=1."]
    #[doc = "  Samples must be stored concatenated in a single flat buffer `samplesBuffer`,"]
    #[doc = "  supplied with an array of sizes `samplesSizes`, providing the size of each sample, in order."]
    #[doc = "  The resulting dictionary will be saved into `dictBuffer`."]
    #[doc = " @return: size of dictionary stored into `dictBuffer` (<= `dictBufferCapacity`)"]
    #[doc = "          or an error code, which can be tested with ZDICT_isError()."]
    #[doc = "  Note: ZDICT_trainFromBuffer() requires about 9 bytes of memory for each input byte."]
    #[doc = "  Tips: In general, a reasonable dictionary has a size of ~ 100 KB."]
    #[doc = "        It\'s possible to select smaller or larger size, just by specifying `dictBufferCapacity`."]
    #[doc = "        In general, it\'s recommended to provide a few thousands samples, though this can vary a lot."]
    #[doc = "        It\'s recommended that total size of all samples be about ~x100 times the target size of dictionary."]
    pub fn ZDICT_trainFromBuffer(
        dictBuffer: *mut libc::c_void,
        dictBufferCapacity: usize,
        samplesBuffer: *const libc::c_void,
        samplesSizes: *const usize,
        nbSamples: libc::c_uint,
    ) -> usize;
}
extern "C" {
    pub fn ZDICT_getDictID(
        dictBuffer: *const libc::c_void,
        dictSize: usize,
    ) -> libc::c_uint;
}
extern "C" {
    pub fn ZDICT_isError(errorCode: usize) -> libc::c_uint;
}
extern "C" {
    pub fn ZDICT_getErrorName(errorCode: usize) -> *const libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTDMT_CCtx_s {
    _unused: [u8; 0],
}
pub type ZSTDMT_CCtx = ZSTDMT_CCtx_s;
extern "C" {
    pub fn ZSTDMT_createCCtx(nbWorkers: libc::c_uint) -> *mut ZSTDMT_CCtx;
}
extern "C" {
    pub fn ZSTDMT_createCCtx_advanced(
        nbWorkers: libc::c_uint,
        cMem: ZSTD_customMem,
    ) -> *mut ZSTDMT_CCtx;
}
extern "C" {
    pub fn ZSTDMT_freeCCtx(mtctx: *mut ZSTDMT_CCtx) -> usize;
}
extern "C" {
    pub fn ZSTDMT_sizeof_CCtx(mtctx: *mut ZSTDMT_CCtx) -> usize;
}
extern "C" {
    pub fn ZSTDMT_compressCCtx(
        mtctx: *mut ZSTDMT_CCtx,
        dst: *mut libc::c_void,
        dstCapacity: usize,
        src: *const libc::c_void,
        srcSize: usize,
        compressionLevel: libc::c_int,
    ) -> usize;
}
extern "C" {
    pub fn ZSTDMT_initCStream(
        mtctx: *mut ZSTDMT_CCtx,
        compressionLevel: libc::c_int,
    ) -> usize;
}
extern "C" {
    pub fn ZSTDMT_resetCStream(
        mtctx: *mut ZSTDMT_CCtx,
        pledgedSrcSize: libc::c_ulonglong,
    ) -> usize;
}
extern "C" {
    pub fn ZSTDMT_compressStream(
        mtctx: *mut ZSTDMT_CCtx,
        output: *mut ZSTD_outBuffer,
        input: *mut ZSTD_inBuffer,
    ) -> usize;
}
extern "C" {
    pub fn ZSTDMT_flushStream(
        mtctx: *mut ZSTDMT_CCtx,
        output: *mut ZSTD_outBuffer,
    ) -> usize;
}
extern "C" {
    pub fn ZSTDMT_endStream(
        mtctx: *mut ZSTDMT_CCtx,
        output: *mut ZSTD_outBuffer,
    ) -> usize;
}
extern "C" {
    pub fn ZSTDMT_compress_advanced(
        mtctx: *mut ZSTDMT_CCtx,
        dst: *mut libc::c_void,
        dstCapacity: usize,
        src: *const libc::c_void,
        srcSize: usize,
        cdict: *const ZSTD_CDict,
        params: ZSTD_parameters,
        overlapLog: libc::c_uint,
    ) -> usize;
}
extern "C" {
    pub fn ZSTDMT_initCStream_advanced(
        mtctx: *mut ZSTDMT_CCtx,
        dict: *const libc::c_void,
        dictSize: usize,
        params: ZSTD_parameters,
        pledgedSrcSize: libc::c_ulonglong,
    ) -> usize;
}
extern "C" {
    pub fn ZSTDMT_initCStream_usingCDict(
        mtctx: *mut ZSTDMT_CCtx,
        cdict: *const ZSTD_CDict,
        fparams: ZSTD_frameParameters,
        pledgedSrcSize: libc::c_ulonglong,
    ) -> usize;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ZSTDMT_parameter {
    ZSTDMT_p_jobSize = 0,
    ZSTDMT_p_overlapSectionLog = 1,
}
extern "C" {
    pub fn ZSTDMT_setMTCtxParameter(
        mtctx: *mut ZSTDMT_CCtx,
        parameter: ZSTDMT_parameter,
        value: libc::c_uint,
    ) -> usize;
}
extern "C" {
    pub fn ZSTDMT_getMTCtxParameter(
        mtctx: *mut ZSTDMT_CCtx,
        parameter: ZSTDMT_parameter,
        value: *mut libc::c_uint,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTDMT_compressStream_generic() :"]
    #[doc = "  Combines ZSTDMT_compressStream() with optional ZSTDMT_flushStream() or ZSTDMT_endStream()"]
    #[doc = "  depending on flush directive."]
    #[doc = " @return : minimum amount of data still to be flushed"]
    #[doc = "           0 if fully flushed"]
    #[doc = "           or an error code"]
    #[doc = "  note : needs to be init using any ZSTD_initCStream*() variant"]
    pub fn ZSTDMT_compressStream_generic(
        mtctx: *mut ZSTDMT_CCtx,
        output: *mut ZSTD_outBuffer,
        input: *mut ZSTD_inBuffer,
        endOp: ZSTD_EndDirective,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTDMT_toFlushNow()"]
    #[doc = "  Tell how many bytes are ready to be flushed immediately."]
    #[doc = "  Probe the oldest active job (not yet entirely flushed) and check its output buffer."]
    #[doc = "  If return 0, it means there is no active job,"]
    #[doc = "  or, it means oldest job is still active, but everything produced has been flushed so far,"]
    #[doc = "  therefore flushing is limited by speed of oldest job."]
    pub fn ZSTDMT_toFlushNow(mtctx: *mut ZSTDMT_CCtx) -> usize;
}
extern "C" {
    #[doc = " ZSTDMT_CCtxParam_setMTCtxParameter()"]
    #[doc = "  like ZSTDMT_setMTCtxParameter(), but into a ZSTD_CCtx_Params"]
    pub fn ZSTDMT_CCtxParam_setMTCtxParameter(
        params: *mut ZSTD_CCtx_params,
        parameter: ZSTDMT_parameter,
        value: libc::c_uint,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTDMT_CCtxParam_setNbWorkers()"]
    #[doc = "  Set nbWorkers, and clamp it."]
    #[doc = "  Also reset jobSize and overlapLog"]
    pub fn ZSTDMT_CCtxParam_setNbWorkers(
        params: *mut ZSTD_CCtx_params,
        nbWorkers: libc::c_uint,
    ) -> usize;
}
extern "C" {
    #[doc = " ZSTDMT_updateCParams_whileCompressing() :"]
    #[doc = "  Updates only a selected set of compression parameters, to remain compatible with current frame."]
    #[doc = "  New parameters will be applied to next compression job."]
    pub fn ZSTDMT_updateCParams_whileCompressing(
        mtctx: *mut ZSTDMT_CCtx,
        cctxParams: *const ZSTD_CCtx_params,
    );
}
extern "C" {
    #[doc = " ZSTDMT_getFrameProgression():"]
    #[doc = "  tells how much data has been consumed (input) and produced (output) for current frame."]
    #[doc = "  able to count progression inside worker threads."]
    pub fn ZSTDMT_getFrameProgression(
        mtctx: *mut ZSTDMT_CCtx,
    ) -> ZSTD_frameProgression;
}
extern "C" {
    #[doc = " ZSTDMT_initCStream_internal() :"]
    #[doc = "  Private use only. Init streaming operation."]
    #[doc = "  expects params to be valid."]
    #[doc = "  must receive dict, or cdict, or none, but not both."]
    #[doc = "  @return : 0, or an error code"]
    pub fn ZSTDMT_initCStream_internal(
        zcs: *mut ZSTDMT_CCtx,
        dict: *const libc::c_void,
        dictSize: usize,
        dictContentType: ZSTD_dictContentType_e,
        cdict: *const ZSTD_CDict,
        params: ZSTD_CCtx_params,
        pledgedSrcSize: libc::c_ulonglong,
    ) -> usize;
}
